# 5월 28일 2일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 2일차 (5/28) | 임현아 | 1.1 비트코인 암호 기초<br />1.2 비트코인이란<br />1.3 비트코인 네트워크 기초 |



## 주요 내용 요약

#### 1.1 비트코인 암호 기초

- ##### 해시함수

  > 어떤 메세지에 대해 짧고 일정한 길이 (128 ~ 512) 의 메세지를 반환하는 함수
 
  1. **일방향성**

     > 메세지(M)과 함수(H)를 통해 나온 값(H(M)) 은 1:1 관계를 갖는다.

  2. **역상 저항성**

     > H(X) = V 에서 V로 X를 찾을 수 없다. => 역함수를 구할 수 없다.

  3. **임의성**

     > 메세지(M) 값이 조금만 달라져도 완전히 다른 값이 생성된다.

- ##### 공개키 암호

  > 암호화에 사용하는 키를 두 개 생성한 후, 그 중 한 개는 **공개(public)**, 다른 한 개는 **비밀(private)** 로 보관
  > `공개 => 공개키`, `비밀 => 개인키`

  * **공개키(K+)** : 주소 생성과 서명 검증 => 공인 인증서와 같은 방식으로 누구나 볼 수 있다.
  * **개인키(K-)** : 서명 생성 => 개인만의 고유한 키로 다른 사람을 알 수 없다.
  * 일반적으로 개인키를 사용하여 암호화를 진행 후, 공개키를 사용하여 복호화를 한다.

- ##### 서명

  > 메세지를 보낼 때, 누가 보내는 지를 함께 보내기 위한 방법

  * **서명 생성**
    * 개인키를 사용하여 메세지(M)의 해시값(H(M))을 암호화
    * 메세지(M)와 서명(E(H(M), K-))을 전송한다.
      => 서명을 생성할 때, 어떤 메세지와 보내는 지(H(M)), 누가 보내는 지(K-)를 E로 묶어 생성한다.
    * `M + E(H(M), K-)` 형태로 전송
  * **서명 검증**
    * 수신한 `M + E(H(M), K-)` 를 다음과 같이 검증한다.
      1. `M`을 해시함수를 사용하여 `H(M)` 형태로 만든다.
      2. `E(H(M), K-)` 를 공개된 `K+`와 복호화(DE) 과정을 거쳐 H(M) 형태만 남긴다.
         `DE(E(H(M), K-), K+)` => `H(M)`
      3. *1*, *2* 의 결과 값이 같은지를 검증한다.
  * 활용
    * 거래 생성자 확인
    * 특정 주소의 코인 소유자 확인



#### 1.2 비트코인이란?

* ##### 비트코인(BTC)

  * 비트코인 네트워크에서 발행되는 통화의 이름
  * 비트코인 통화가 운영되는 네트워크 시스템 전체
    * 블록체인 (거래장부 - 트랜잭션이 담긴 블록을 체인으로 엮은 것)
    * 블록 전송을 위한 네트워크
    * 블록체인을 생성하고 검증하는 채굴자 집합


* ##### 비트코인의 출현

  * P2P 전자화폐 시스템
  * 공개키 기반의 주소에 대응되는 서명에 의한 증명
    

* ##### 비트코인의 특징

  * 모든 지불 거래 정보를 블록체인에 저장
  * 블록체인에서 승인된 거래 기록 변경 불가
  * 누구나 블록체인 생성에 참여 가능
  * 누구나 블록체인 유지 및 내역 확인 가능
  * Legder(원장 - 거래 승인, 전자 화폐 이동) 관리
  * 이중 지불 불가



#### 1.3 비트코인 네트워크 기초

* ##### 기존 금융 네트워크

  * 중앙기관에 의해 구축, 운영
  * 클라이언트 - 서버 네트워크

* ##### 비트코인 네트워크

  * 운영주체가 없이 참여자들이 자발적으로 구축, 운영
  * 참여자들의 컴퓨터를 연결한 P2P 네트워크
  * 누구든지 (node)로 참여가 가능 - 채굴, 거래소 등
  * 참여를 통한 인센티브로 비트코인을 제공.

* ##### 네트워크의 익명성

  * 암호학적으로 생성되는 비트코인의 주소를 사용하므로, 사용자가 누구인지 바인딩 하는 과정을 존재하지 않아 익명성이 보장됨

* ##### 비정상적인 참여자 존재 가능

  * 누구나 참여가 가능하므로, 불안정하고 속도가 느린 부실한 컴퓨터나, 악의적 사용자가 운연하는 악성 컴퓨터 노드가 존재할 수 있다.
  




---
  

# 5월 29일 3일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 3일차 (5/29) | 임현아 | 1.4 비트코인 전자화폐 거래개념 <br />1.5 비트코인 블록체인 개요 |


#### 1.4 비트코인 전자화폐 거래개념

- ##### 거래의 목표

  - P2P 거래

    > 모든 거래는 당사자간에 P2P방식으로 이루어짐

  - 안전하고 투명한 거래 

    > 모든 지불 거래 내역이 public ledger인 블록체인에 기록

- ##### 화폐 발행의 주체

  - 채굴자 

    > 블록을 생성, 체인으로 연결하는 참여자

  - `작업 증명 알고리즘` - 채굴 역량에 비례하는 확률로 임의의 채굴자를 자동으로 선정

  - 채굴자가 선정되면, 해당 채굴자의 주소로 블록 보상인 비트코인을 송신하는 거래 내역을 트랜잭션에 기록해 블록 첫번째에 등록 (**CoinBase**)

- ##### 화폐 소유자 증명

  - 소유자 증명 방식

    - 지불 거래 생성시 소유자 증명 방식을 명시한다.
      예.) 수신자 주소에 대응되는 서명 제시를 요구
    - locking script를 unlocking script 로 풀 수 있도록 한다.

- ##### 지불 거래

  - CoinBase 
  

    ![img](https://lh5.googleusercontent.com/74vOXykI7FOfOTFepLd_3_JY3RuY19d2oyhZ8cNZQz2VbqY2LcNkh4-vgKyII_A3ZyOIBSL7FTDQ9T3P9HDfQCdQ-3moz3B0CG6CyrBr-zraCgtlQ2LF_lEZjj_lYR6XwdlmvXUf)
    
    입력값

  - > 해시값 : 출력값에 대한 해시값
    > 서명 : 소유자 증명을 위한 서명

  - 지불 거래
  - 
    ![img](https://lh4.googleusercontent.com/xrn4P7tjsMQU_yckx-szzXeCEmEAUdZ-KyzjphY5QWAgkfNa3IwRHMhX3Mm7KWMfbz9l57oMS8fSltXYs8jtSZAB49SH6IcPKe80LQB9lpYhpx5Ch5Cd3gWxnft9MsyxNtSwABi7)

    - `입력값의 금액 - 출력값의 금액` = 수수료
    - 한번 해시포인터로 지정된 비트코인은 사용이 되었으므로 더이상 사용할 수 없다.
    - 출력값에는 `보내는 금액`, `주소`, `소유자 증명 방식` 기술

  - 지불 거래의 일반적인 형식
  - 
    ![img](https://lh3.googleusercontent.com/FjC0sfzdYRPmj2sEXxD9HUrc57QZ3x1kQ33tYk5En_lVCWHQyv1y41zTCUK8sNgPGWS5a6bfDdMIzHN5Yc0HReQSynXgyYZFY1FtrqBS13kGYS3SLXv6LIbiVEwGVb2gI_BGEuzU)

    - UTXO 

      > 내 주소로 받았는데 아직 사용되지 않은 화폐
      > → 해시포인터로 지정되지 않은 화폐

    - STXO 

      > 받은 화폐중에 이미 사용된 화폐
      > → 해시포인터로 지정이 된 화폐를 의미.

    - 결과적으로,
      블록체인 상의 UTXO의 총합 = 발행된 비트코인의 총액,
      내 지갑의 모든 비트코인의 총액 = 내 주소의 UTXO의 총합.

- 이중 지불 거래 방지

  - 이중 지불이란?

    > STXO를 다시 사용하는 지불거래

  - UTXO 전체 단위로 사용 ⇒ 수신된 비트코인의 일부만 사용하는 것은 불가
    

#### 1.5 비트코인 블록체인 개요

- ##### 블록체인의 역할

  - 비트코인의 지불 거래 정보를 기록한 장부
  - 발행, 이동 내역을 보여주는 장부
  - P2P 거래를 가능하게 하는 원천

- ##### 블록체인의 목표

  - **완전성**

    > 모든 거래를 일관성있게 기록, 누구든지 모든 비트코인의 현황을 확인할 수 있다.

  - **안전성**

    > 비정산 거래 기록 불가, 승인된 거래 변경/교체 불가, 블록체인 파괴 불가

  - **분산성 / 비집중성**

    > 누구든지 참여 가능, 의존되지 않으며 일관성이 보장.

  - **투명성**

    > 누구나 블록체인 접근, 검증, 사용 가능.
    > 채굴자가 아니여도 접근 가능 (SPV노드)

- ##### 비트코인 네트워크 참여자

  - 풀 노드 참여자
  - 채굴 노드 참여자
  - SPV 노드

- ##### 비트코인

  - 블록

    > 일정 시간(대략 10분) 동안 교환되는 모든 거래를 검증한 후, 모아서 만든 자료구조 → 장부
    > 생성 후, 모든 네트워크 참여자에게 전달 ⇒ 자신의 블록체인에 수신된 블록을 연결

    - 블록 크기 : 1Mbyte로 제한 (일반적으로 초당 7개의 거래)
      ⇒ 블록 전달 지연시간이 커지는 것을 방지

  - 블록 채굴자 결정

    > PoW (작업증명)에 가장 먼저 성공한 채굴자 ⇒ 그만큼 PC 성능이 좋아야함
    > 예.) 난이도 목표값보다 작은 해시값을 생성하는 넌스

    - 생성한 블록 배포시에 해시값을 포함해, 채굴자가 성공한 것을 누구나 확인 가능하게 함

  - 블록 조작 불가
  
    ![img](https://lh5.googleusercontent.com/07udbAVI70PmgMWszgxASxfPeCCycBHevGbRLRllg7j3YfKh5sN6Zh2HfUmvRnOgjyS_JN4ejuRJqW1_q0Up-eJNBpt5Rc43A-6dc-vtmcPBfMlOqdboa2rZ2ii01AkFuzyH83BB)

  - - **51% Attack** : 51% 이상의 해시파워를 소유한 집단이 공격을 한다면 가능하겠지만, 현실적으로는 불가능하다.

- ##### SPV 노드

  > 블록 헤더(해시 포인터, 난이도 목표, 넌스, 머클 루트) 정보만 유지

  - 머클 트리 : 거래들을 모아놓은 해시 트리
  
    ![img](https://lh5.googleusercontent.com/DlnpEDF7nqEIJev3H9Ccf6klsKq6Ur_Li9tW1cL07ikti3Wx0jurDXLOqRRLr_Px4p_9VXabrIMg6cZT6uOQYT0c3xBX4hpWxOyf9KVBXyb_tLV4jIE5fh3S0QtgP-AC9Vu1Nis9)

  - 머클 경로 : 특정 거래의 존재 증명에 필요한 일련의 해시 노드

    - 거래 k (Hk) 의 머클 경로 ⇒ HI → Hij → Hmnop → Habcdefgh

    - 계산 방법

      > `Hk` + `Hl` ⇒ `Hkl`
      > `Hkl` + `Hij` ⇒ `Hijkl`
      > `Hijkl` +`Hmnop` ⇒ `Hijklmnop`
      > `Hijklmnop` + `Habcdefgh` ⇒ `머클루트`

    - 머클 경로를 사용하면 굳이 머클 트리 전체를 저장할 필요가 없다.

    - 머클 경로의 크기 : log2N

  - SPV 노드의 거래 승인 확인

    - 관심있는 거래의 머클 경로만 다운로드
      해시값 계산 결과와 자신이 보유한 블록 헤더의 머클 루트와 비교




 ---
  

# 5월 30일 4일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 4일차 (5/30) | 임현아 | 1.6 비트코인 스마트거래의 구조 <br />1.7 비트코인 작업증명과 인센티브 |



#### 1.6 비트코인 스마트거래의 구조

* 비트코인 거래(transaction)

  > 참여자들이 비트코인 통화 등 가치를 주고 받고 상호 인정하는 행위를 규정하는 데이터 구조

  * 비트코인 지불 거래

    > **블록체인** 상에서 **입력값(자금원)**에서 **출력값(목적지)** 으로 자금을 전달하는 행위 

    ![img](https://lh3.googleusercontent.com/xm3Guskp8fusCzlTLEF5aBiQtT7UmQL9c1Wv4X96WeCxzlFBPMmZBlNgMKAeFHyJ51j-SkTuVbsr76lnpit1054CPcu0nY_xtFAXbq8RAS-oxbrbdmBV_bpKw9T3dK3MaDkuGx6S)

    ⇒ 입력값 0 : 철수가 가진 자금 (이전 거래의 출력값을 해시포인터로 가르킨다.)
    ⇒ 출력값 0 : 철수가 영희에게 보내는 부분
    ⇒ 출력값 1 : 남은 거스름 돈을 철수에게 보내는 부분

    * 일반적 지불 거래

      >이전 거래의 UTXO를 거래에 사용하므로, 거래에 사용된 자금이 UTXO인지를 확인하기 위해 RAM메모리 풀에 전체 UTXO들을 유지한다. 

    * 거래 수수료 : `입력값 총합 - 출력값 총합` 

  * 자금 분산 거래
  
    ![img](https://lh5.googleusercontent.com/FRKfVU1DqHlSFF7xI9-PjuF6dkFkhrkZKSC0AxeTSgIJjIO9Pmk14v1xSbM4wlZKGXa_gnZjZwxWe7xMN5ZG3x2Ax2QrfBJgYB7JzH5TkYlHMK-wq9mMhJeX8exYMAvtT3UaamcH)

  * 코인베이스 거래

    > 채굴자에게 네트워크가 자동으로 신규 비트코인을 지불하는 거래

    * 출력값 : `금액`, <u>`잠금 스크립트`</u> 로 이루어진다. ⇒  잠금 스크립트 내부에 수신자 포함
      * 잠금 스크립트

        > 해당 출력값을 소비하기 위해 충족시켜야 하는 조건을 기술한 간단한 프로그램

        ```
        예.) scriptPubKey = DUP HASH160 <PubKHash> EQUALVERIFY CHECKSIG
        ```

    * 입력값 : `거래 해시포인터`, `출력값 인덱스`,<u>`해제 스크립트`</u>, `일련번호`

      * 해제 스크립트

        > 서명과 공개키를 데이터로 제공

        ```
        예.) scriptSig = <sig><pubK>
        ```

    * 비트코인 스택 언어 : 거래 실행 - `해제 스크립트` 와 `잠금 스크립트` 의 연결

      ```
      <sig> <pubK> + DUP HASH160 <PubKHash> EQUALVERIFY CHECKSIG
      ```

      > 1. 스택 자료 구조에 해제 스크립트 데이터를 push
      > 2. 명령을 한번씩만 수행 (loop 명령 미지원) - [튜링 불완전 언어]

      * 주요 명령어
        * <data> : 데이터(data)를 스택에 push
        * OP_DUP : top 데이터를 복제한 후 스택에 push
        * OP_HASH160 : pop 한 데이터를 HSA256으로 해싱 ⇒ PEMD160으로 해싱한 결과를 push
        * OP_EQUALVERIFY : 맨 위 두개의 데이터를 pop 하여 같으면 true, 다르면 false를 반환
        * OP_CHECKSIG : 맨 위 공개키와 다음의 서명을 pop, 공개키로 서명을 검증 
          ⇒ 같으면 true, 다르면 false를 반환
        * OP_CHECKMULTISIG : N개의 공개키를 사용, M개의 서명을 검증
          ⇒ 같으면 true, 다르면 false를 반환

      ![img](https://lh3.googleusercontent.com/ezxvsKX2gF8weNunl0hTdSvbmar6pvtJAi8dMwHGXl1jcluWRo79t8HCFJ3-MBhbjCURxl6vbrnxEJ2o7_5APt7ZVxUW6XqURdjTk28-PJbvUL-Tf-8sqE8h7d2ov4hbe0iVI_cv)

  * 특징

    * 거래 조건을 프로그램으로 설정하기 때문에, 다양한 유형의 스마트 거래 개발이 가능하다.

    * 튜링 불완전 언어이기 때문에 복잡한 거래 개발에는 어렵다.

      ⇒ 튜링 완전 언어를 사용하는 화폐는 이더리움



#### 1.7 비트코인 작업증명과 인센티브

* 블록 채굴 정책

  * 목표

    > 채굴자들간에 블록에 대한 합의

  * 수단

    1. 블록 인센티브 정책

       * 블록 보상

         > 블록 채굴에 성공한 채굴자에게 네트워크가 자동으로 지급
         > 시간이 감에 따라 지급량이 축소되도록 설계

       * 거래 수수료

         > 거래 수수료 보상 = `블록의 전체 거래 입력값 총합` - `블록의 전체 거래의 출력값 총합`

       ⇒  코인베이스 거래

       > 블록 채굴에 대한 전체 인센티브는 블록의 첫번째 거래인 코인 베이스 거래에 의해 지불
       > 	출력값 ⇒ `블록 보상` + `거래 수수료`

    2. 작업 증명 정책

       > 블록 헤더에 대한 HSA256 해시값이 목표보다 작아질 때까지 블록 헤더의 일부 값(넌스)를 변경하면서 블록 헤더의 해시값 계산을 반복, 목표보다 작은 값이 발견되면 작업 증명에 성공
       > ⇒ 채굴된 블록을 수신한 다른 채굴자는 블록 헤더의 HSA256 해시값이 목표값보다 작은 지 확인함으로 작업 증명을 검증

       * 블록 헤더 
         `버전` + `해시포인터` + `머클 루트` + `타임스탬프` + `난이도 목표` + `넌스`  로 구성

       * 해시함수 특징

         * 일방향성 

           > 해시값으로부터 원래 데이터를 추론할 수 없음을 보장
           > 따라서, 목표보다 작은 해시값을 정해놓고 거기에 맞는 넌스를 추론하는 것이 불가.

         * 임의성

           > 반복 계산 외의 다른 방법으로 작업 증명을 할 수 없음.

       * 해시율 

         > 해시 함수 적용 능력 = 초당 해시 함수 계산 능력
         > **채굴자의 작업증명 성공 확률** 
         >      = (`채굴자의 해시율`/`전체 채굴자의 해시율 총합`)

  
 ---
  

# 5월 31일 5일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 5일차 (5/31) | 임현아 | 2.1 자바를 사용하여 기본적인 블록체인 만들기 <br />2.2 PoW(Proof of Work) 알고리즘 구현하기 |



#### 2.1 자바를 사용하여 기본적인 블록체인 만들기

* ##### 블록체인 만들기

  > 기본적인 블록체인을 만들기 위해서 필요한 구조는 다음과 같다.
  >
  > * 블록 : `이전 블록의 해시값`, `현재의 해시값`, `데이터`, `생성된 시간`, `증명에 필요한 nonce` 로 이루어짐
  > * util : 블록을 생성할 때 필요한 util 모음
  > * 블록체인 : 블록을 연결하는 Main 클래스

  

  * 블록 [Block.java]

    > 블록체인을 구성하는 블록의 구조를 만들어 놓아야하므로 다음과 같은 변수를 갖는다.

    ```java
    	public String hash; // 디지털 서명을 저장.
    	public String previousHash; // 이전 해시값을 저장.
    	private String data; // 블록에 저장하는 메세지
    	private long timeStamp; // 블록이 생성될때의 시간을 기록
    	private int nonce; // proof of work를 진행할 수 있도록 하는 변수.
    ```

    

    > ![img](https://lh4.googleusercontent.com/swNGKCxbmKyTO-qhr3TtB7t8_-XMGYiPxSbVYh5B-HMYe9MRmOL7IN8g0YMniPepg03IybB8pb-BNj9NnNLJeHySl6TQRDLMh6KuP3Xd5fqBCLVwRt-O7KywtsFBq0jZ42KWHuoR)
    >
    > 블록을 생성할 때 데이터와 이전 블록의 해시값을 받아와 다음과 같이 생성한다.

    ```java
    	// 블록 생성자
    	public Block(String data, String previousHash) {
    		this.previousHash = previousHash;
    		this.data = data;
    		this.timeStamp = new Date().getTime();
    		this.hash = calculateHash();
    	}
    
    	// Hash 값을 계산하는 부분
    	public String calculateHash() {
    		String calculatedhash = StringUtil.applySha256(
    				previousHash + 
    				Long.toString(timeStamp) + 
    				Integer.toString(nonce) + 
    				data
    				);
    		return calculatedhash;
    	}	
    ```

    

  * Util [StringUtil.java]

    > 블록체인을 생성하기 위해서 해시값을 가져오는데, 그 부분을 해결할 함수를 만드는 클래스이다.
    >
    > 다음 함수에서, 하나의 input으로 String값을 가져와 SHA256으로 Hashing을 한 뒤, 한 글자씩 16진수로 변환하여 StringBuffer에 append한 후 하나의 String으로 반환한다.

    ```java
    	public static String applySha256(String input) {
    		try {
    			// 크립토그래픽 알고리즘을 SHA256으로 사용.
    			MessageDigest digest = MessageDigest.getInstance("SHA-256");
    			
    			// input을 SHA256으로 넣고 hash value.
    			byte[] hash = digest.digest(input.getBytes("UTF-8"));
    			StringBuffer hexString = new StringBuffer();
    			for(int i=0; i<hash.length; i++) {
    				String hex = Integer.toHexString(0xff & hash[i]);
    				if(hex.length() == 1) hexString.append('0');
    				hexString.append(hex);
    			}
    			
    			// 하나의 문자열로 만들어 return
    			return hexString.toString();
    		} catch (Exception e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		return null;
    	}
    ```

    

  * 블록체인 [NoobChain.java]

    > 블록을 생성하고 체인으로 엮는 클래스

    ```java
    	public static ArrayList<Block> blockchain = new ArrayList<>();
    
    	public static void main(String[] args) {
    		// ArrayList에 Block 추가.
    		blockchain.add(new Block("Hi Im the first block", "0"));
    		System.out.println("Trying to Mine block 1...");
    
    		blockchain.add(new Block(
                "Yo! Im the second block", blockchain.get(blockchain.size()-1).hash));
    		System.out.println("Trying to Mine block 2...");
    		
    		blockchain.add(new Block(
                "Yo! Im the third block", blockchain.get(blockchain.size()-1).hash));
    		System.out.println("Trying to Mine block 3...");
    		
    		System.out.println("\nBlockchain is Valid : " + isChainValid());
    		
            // 생성된 블록체인을 json타입으로 출력.
    		String blockchainJson = 
                new GsonBuilder().setPrettyPrinting().create().toJson(blockchain);
    		System.out.println("\n***** The block chain *****");
    		System.out.println(blockchainJson);
    	}
    ```

    > 위와 같이 ArrayList에 Block들을 엮으며, 이전 블록의 해시값을 생성하는 블록의 해시값에 대입한다.



#### 2.2 PoW(Proof of Work) 알고리즘 구현하기

* ##### PoW (Proof of Work) 란?

  > 블록체인 상에 존재하는 블록의 유효성을 검증하는 방식
  >
  > 이 블록체인 안에서의 유효성을 검증하기 위하여, 각 블록에 저장되어 있는 previousHash값과 실제 이전의 블록의 hash값을 비교하는 방식을 사용한다.

  ```java
  	// 블록체인의 무결성 검사
  	public static Boolean isChainValid() {
  		
  		Block currentBlock;
  		Block previousBlock;
  		
  		//블록체인 안의 해시값 검사.
  		for(int i=1; i<blockchain.size(); i++) {
  			currentBlock = blockchain.get(i);
  			previousBlock = blockchain.get(i-1);
  
  			// hash에 변화가 생기면 false를 리턴
  			if( !currentBlock.hash.equals(currentBlock.calculateHash()) ) {
  				System.out.println("Current Hashes not equal");
  				return false;
  			}
  			if( !previousBlock.hash.equals(currentBlock.previousHash) ) {
  				System.out.println("Previous Hashes not equal");
  				return false;
  			}
  		}
  
  		return true;
  	}
  ```

  >  블록체인을 생성한 뒤, 해당 블록체인의 유효성을 검사해주면 된다. 만약, 이전 블록의 해시값과 현재의 해시값이 다르다면 false를 리턴하게 되므로, 현재 생성되는 블록체인의 유효성을 검사할 수 있다.  

  

* 난이도(Difficulty) 생성하기

  > 블록을 생성할 때, 채굴자는 난이도에 설정된 만큼의 0으로 이루어진 해시값을 찾아야 하고 그만큼 돌아간 nonce(넌스)가 가장 낮은 채굴자에게 보상을 제공하게 된다.
  >
  > 먼저, 난이도를 블록체인 부분에서 생성한 뒤, 블록을 채굴하는 명령을 보낸다.

  ```java
  	public static int difficulty = 5;
  	
  	/*------------------Main 부분------------------*/
  
  	blockchain.get(0).mineBlock(difficulty);
  ```

  

  > 블록 내부에서 현재의 hash값에서 난이도만큼이 0으로 채워져 있는 지를 체크한 후,  
  > 채워져 있지 않으면 다시 hash값을 생성하는 것을 반복한다.(Brute Force) 

  ```java
  	// hash값의 일정 자리수 (difficulty) 만큼 target이 일치하는지를 검사하는 부분 
  	// -> 채굴자들이 proof-of-work를 진행하는 부분.
  	public void mineBlock(int difficulty) {
  		String target = new String(new char[difficulty]).replace('\0', '0');
  		while(!hash.substring(0, difficulty).equals(target)) {
  			nonce++;
  			hash = calculateHash();
  		}
  		System.out.println("Block Mined!!! : " + hash);
  	}
  ```



#### => 결과

> 위와 같이 블록체인을 구현하게 되면 결과는 다음과 같이 나오게 된다.

```
Trying to Mine block 1...
Block Mined!!! : 0000083ac847e645bc0ea3b6c11ea502ddebfb230f85aa967df19fd3ae21558f
Trying to Mine block 2...
Block Mined!!! : 000008bc1ea2cabe62cc0d56459798225e342e776b7cc0f9821e749a3c606acc
Trying to Mine block 3...
Block Mined!!! : 000001c0b1e87ff90c3ab2dfd994590a13d577a574419caf2a6462cf9392eeb9

Blockchain is Valid : true

***** The block chain *****
[
  {
    "hash": "0000083ac847e645bc0ea3b6c11ea502ddebfb230f85aa967df19fd3ae21558f",
    "previousHash": "0",
    "data": "Hi Im the first block",
    "timeStamp": 1559292325076,
    "nonce": 606876
  },
  {
    "hash": "000008bc1ea2cabe62cc0d56459798225e342e776b7cc0f9821e749a3c606acc",
    "previousHash": "0000083ac847e645bc0ea3b6c11ea502ddebfb230f85aa967df19fd3ae21558f",
    "data": "Yo! Im the second block",
    "timeStamp": 1559292326097,
    "nonce": 4276428
  },
  {
    "hash": "000001c0b1e87ff90c3ab2dfd994590a13d577a574419caf2a6462cf9392eeb9",
    "previousHash": "000008bc1ea2cabe62cc0d56459798225e342e776b7cc0f9821e749a3c606acc",
    "data": "Yo! Im the third block",
    "timeStamp": 1559292333258,
    "nonce": 331426
  }
]
```


---

# 6월 3일 6일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 6일차 (6/3) | 조원철 | 2.3 지갑(Smart Wallet) 만들기<br />2.4 트랜잭션(Transaction) 구현하기 |



#### 2.3 지갑(Smart Wallet) 만들기

* ##### 지갑(Smart Wallet) 이란?

  > 블록체인 안에서 새로운 **트랜잭션**을 생성할 수 있는 소프트웨어

  * 지갑 내부에 포함되어야 할 것

    * 공개키 (Public Key)
    * 개인키 (Private Key)

  * 지갑(Wallet) 구현

    > 지갑을 생성하기 위해서 필요한 Public Key, Private Key가 담겨져 있는 
    > `java.security.*`를 import해서 사용한다.

    ```java
    public PrivateKey privateKey; // 개인키
    	public PublicKey publicKey; // 공개키
    
    	public HashMap<String, TransactionOutput> UTXOs 
    					= new HashMap<String, TransactionOutput>();
    
    	public Wallet() {
    		generateKeyPair();
    	}
    
    	public void generateKeyPair() {
    		try {
    			KeyPairGenerator keyGen = KeyPairGenerator.getInstance("ECDSA", "BC");
    			SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
    			ECGenParameterSpec ecSpec = new ECGenParameterSpec("prime192v1");
    
    			// Initialize the key generator and generate a KeyPair
    			keyGen.initialize(ecSpec, random);
    			KeyPair keyPair = keyGen.generateKeyPair();
    
    			// Set the public and private keys from the keyPair
    			privateKey = keyPair.getPrivate();
    			publicKey = keyPair.getPublic();
    		} catch (Exception e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    
    	}
    ```

    

  

#### 2.4 트랜잭션(Transaction) 구현하기

* ##### 트랜잭션이란?

  > 하나의 거래에 대해 필요한 정보들을 담고 있는 단위
  > 
  >![img](https://lh4.googleusercontent.com/I-0WFdedfIATZrMBKkWO74s9tGpGX_uRJThHjxZSWEWxU5nFaCBXn9XucG8G2E8aMsG_rW60Z3XJQGx8xrifmG7gFhqYxtrHEV-RTZI471CcQeMu_2jedK5wFAWWLM9Zg9wsTdM3)

  * 트랜잭션에 포함되어야 할 것

    * 발신자의 공개키 (address)
    * 수신자의 공개키 (address)
    * 보내지는 계좌의 수량 혹은 금액
    * 보내는 사람의 계좌를 증명할 이전 트랜잭션들의 레퍼런스 인풋
    * 트랜잭션에서 받아진 금액을 보여주는 아웃풋

    ```java
    	public String transactionId;	// 트랜잭션 ID
    	public PublicKey sender;		// 발신자의 KEY
    	public PublicKey reciepient; 	// 수신자의 KEY
    	public float value;
    	public byte[] signature;		// 서명
    	
    	public ArrayList<TransactionInput> inputs = new ArrayList<>();
    	public ArrayList<TransactionOutput> outputs = new ArrayList<>();
    	
    	private static int sequence = 0; // 몇 개의 트랜잭션이 생성되었는지
    
    
    	public boolean processTransaction() {
    		if(verifySignature() == false) {
    			System.out.println("#Transaction Signature failed to verify");
    			return false;
    		}
    		
    		//gather transaction inputs (Make sure they are unspent):
    		for(TransactionInput i : inputs) {
    			i.UTXO = NoobChain.UTXOs.get(i.transactionOutputId);
    		}
    		
    		//check if transaction is valid:
    		if(getInputsValue() < NoobChain.minimumTransaction) {
    			System.out.println("#Transaction Inputs to small: "
                                   + getInputsValue());
    			return false;
    		}
    		
    		//generate transaction outputs:
    		float leftOver = getInputsValue() - value; /
    		transactionId = calulateHash();
    		outputs.add(new TransactionOutput(this.reciepient, value, transactionId)); 
    		outputs.add(new TransactionOutput(this.sender, leftOver, transactionId)); 
    		
    		//add outputs to Unspent list
    		for(TransactionOutput o : outputs) {
    			NoobChain.UTXOs.put(o.id, o);
    		}
    		
    		//remove transaction inputs from UTXO lists as spent:
    		for(TransactionInput i : inputs) {
    			if(i.UTXO == null) continue; //if Transaction can't be found skip it
    			NoobChain.UTXOs.remove(i.UTXO.id);
    		}
    		
    		return true;
    	}
    ```

    

* ##### Signature (서명) 이란?

  > 실제 코인의 주인만이 사용할 수 있도록 하며, 블럭의 생성이 시작되는 시점에서 이미 접수된 트랜잭션을 다른 사람들이 수정하지 못하도록 한다.
  >
  > * private Key : 데이터를 서명하는데 사용
  > * public Key : 해당 Key가 사실인지를 확인하는데 사용

  ```java
  	public void generateSignature(PrivateKey privateKey) {
  		String data = StringUtil.getStringFromKey(sender) + 
  			StringUtil.getStringFromKey(reciepient) + Float.toString(value);
  		signature = StringUtil.applyECDSASig(privateKey, data);
  	}
  	
  	public boolean verifySignature() {
  		String data = StringUtil.getStringFromKey(sender) + 
  			StringUtil.getStringFromKey(reciepient) + Float.toString(value);
  		return StringUtil.verifyECDSASig(sender, data, signature);
  	}
  ```

  

* ##### UTXO?

  > Unspent Transaction Output 으로 사용되지 않은 코인(data, value)를 말한다. 
  >
  > 따라서, 사용되지 않은 해당 주소의 잔액을 알고 싶다면 해당 주소의 UTXO를 모으면 된다.



---

# 6월 4일 7일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 7일차 (6/4) | 조원철 | 2.5 P2P(Peer 2 Peer) Network 알아보기<br />2.6 Consensus algorithm |




#### 2.5 P2P(Peer 2 Peer) Network 알아보기

* ##### P2P Network 의 종류

  * ##### 하이브리드P2P

    ##### ![img](https://lh5.googleusercontent.com/zKXB2d59p-gg92Ub243n0M3vBdGWRy3sugd0AZEzGYBZqDdkZ6rH3oX7m6WTaKwF8k7x2J45E-5Nfg8KNV8k7TkhHE253uAmO7O-eBty7wQhyIrDVQx38cmtKy8Anqr4thiulAlR)

    > 기존 서버-클라이언트를 중개 및 검색을 제공, 개인들 간의 데이터를 주고받는 방식
    >
    > 검색이 빠르다는 장점, 사용자가 많아질수록 서버의 부담이 커지고 서버가 죽으면 사용하지 못한다는 단점이 존재

  * ##### Pure P2p

    ##### ![img](https://lh6.googleusercontent.com/zMfxrdPsSaibaRIElbxZJ5Xf65ILTNb-dr5drFUdlPA4h8U-GmBNnMyAvbIFnS4M6ai-9cATGeFpVmN33dFu7Z08HYdqJw0YnTxrYbxZh__2Zr_C-eHsPQeDDtvrjxP0l62SiKxM)

    > 중앙 서버 없이 네트워크에 참여하는 모든 컴퓨터가 서버와 클라이언트를 담당
    > 한 대가 문제가 생겨도 네트워크 전체에는 문제가 없고 비용이 적지만, 네트워크를 제어할 수 없고 검색 속도가 느리다는 단점이 존재



* ##### P2P Network에 따른 블록체인의 종류

  * ##### Public BlockChain

    > Pure P2P를 사용하는 방식으로 비트코인과 이더리움에 사용

    

  * ##### Private BlockChain

    > 하이퍼레저나 코르다와 같은 방식으로 각 노드마다 역할이 다르다. 하이브리드 P2P를 사용한다.

    

#### 2.6 Consensus algorithm

* 합의 알고리즘이란?

  > 블록체인 네트워크 상에서 서로 신뢰 관계가 없는 노드가 의사 결정을 하기 위해 사용되는 알고리즘.

* 합의 알고리즘의 종류
  * POW
  * POS
  * DPOS




---

# 6월 5일 8일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 8일차 (6/5) | 조원철 | 2.7 블록체인 정리  |




#### 2.7 블록체인 정리

* 개인키/공개키 파일 작성

  > 개인키와 공개키를 pem 형태로 저장, 그것을 사용해서 검증을 진행할 수 있다.

  ```java
  // Pem 클래스로 생성된 암호키를 파일로 저장.
  	private void writePemFile(Key key, String description, String filename) {
  		Pem pemFile = new Pem(key, description);
  		pemFile.write(filename);
  		System.out.println(String.format("EC 암호키 %s을(를) %s 파일로 내보냈습니다.", description, filename));
  	}
  
  	// 문자열 형태의 인증서에서 개인키를 추출하는 함수
  	public PrivateKey readPrivateKeyFromPemFile(String privateKeyName) {
  		try {
  			String data = readString(privateKeyName);
  			System.out.println("EC 개인키를 " + privateKeyName + "로부터 불러왔습니다.");
  			System.out.println(data);
  
  			data = data.replaceAll("-----BEGIN EC PRIVATE KEY-----", "");
  			data = data.replaceAll("-----END EC PRIVATE KEY-----", "");
  
  			// PEM 파일은 Base64로 인코딩 되어있어 디코딩 해준다.
  			byte[] decoded = Base64.decode(data);
  			PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);
  			KeyFactory factory;
  			factory = KeyFactory.getInstance("ECDSA");
  			PrivateKey privateKey = factory.generatePrivate(spec);
  			
  			return privateKey;
  		} catch (Exception e) {
  			// TODO Auto-generated catch block
  			e.printStackTrace();
  		}
  		return null;
  	}
  
  	// 문자열 형태의 인증서에서 공개키를 추출하는 함수입니다.
  
  	public PublicKey readPublicKeyFromPemFile(String publicKeyName)
  			throws FileNotFoundException, IOException, NoSuchAlgorithmException, InvalidKeySpecException {
  		String data = readString(publicKeyName);
  		System.out.println("EC 개인키를 " + publicKeyName + "로부터 불러왔습니다.");
  		System.out.println(data);
  
  		// 불필요한 설명 구문을 제거합니다.
  		data = data.replaceAll("-----BEGIN EC PUBLIC KEY-----", "");
  		data = data.replaceAll("-----END EC PUBLIC KEY-----", "");
  
  		// PEM 파일은 Base64로 인코딩 되어있으므로 디코딩해서 읽을 수 있도록 합니다.
  		byte[] decoded = Base64.decode(data);
  		X509EncodedKeySpec spec = new X509EncodedKeySpec(decoded);
  		KeyFactory factory = KeyFactory.getInstance("ECDSA");
  		PublicKey publicKey = factory.generatePublic(spec);
  		return publicKey;
  	}
  
  	// 특정한 파일에 작성되어 있는 문자열을 그대로 읽어오는 함수입니다.
  	private String readString(String filename) throws FileNotFoundException, IOException {
  		String pem = "";
  		BufferedReader br = new BufferedReader(new FileReader(filename));
  		String line;
  
  		while ((line = br.readLine()) != null)
  			pem += line + "\n";
  		br.close();
  
  		return pem;
  	}
  ```

  

* P2P 구현 설계

  > 1. 각각의 채굴자 PC에서 블록체인을 생성하면 해당 PC에 블록체인과 채굴자들의 키 값을 저장한 파일을 저장한다. 
  > 2. 채굴자들의 정보에 ip와 port를 저장하여 트랜잭션이 생길 때마다 각각의 채굴자들의 pc에 트랜잭션 정보를 보내 생성하는 블록에 트랜잭션을 추가할 수 있도록 한다
  > 3. 생성한 지 10분이지나면 각각의 블록이 유효한 지 검증을 한 후, 블록을 체인에 묶는다.
  
  
  
  
  

---

# 6월 7일 9일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 9일차 (6/7) | 조원철 | 2.8 블록체인 구현 및 실습하기  |

  
  
  
  
  
  
#### 2.8 블록체인 구현 및 실습하기

* SHA-256 해시 연산을 수행해주는 기능은 유틸(Util) 클래스에 담아주기 위해 Util 클래스 만들기

  1. 클래스 생성 이후에는 바로 SHA-256 연산을 수행하는 메소드(Method)를 구현

     > 위 소스코드를 보면 MessageDigest라는 라이브러리를 이용해서 ‘SHA-256’ 해시 알고리즘을 사용하겠다고 명시한 것을 알 수 있다. 이후에 사용자로부터 받은 입력을 SHA-256 해시를 적용하여 그 값을 바이트(Byte) 배열 형태로 반환하도록 함수가 작성되었다.
     >
     > 쉽게 말해 위 그림과 같이 우리가 작성한 getHash() 함수는 단순한 문자열이 들어왔을 때 그것을 SHA-256 해시를 적용한 결과 값으로 바꾸어주는 단순한 함수라고 할 수 있다. 이 때 자바에서는 메소드와 함수는 동일한 의미로 사용된다. 이제 이렇게 만들어 본 메소드를 직접 사용해보는 소스코드를 작성해보자.

  2. 블록체인 구동기(Block Chain Starter)라고 클래스 작성

     >  해당 클래스는 실제로 소스코드가 처음 실행되는 진입점 역할을 수행하므로 메인 메소드(Main Method)를 추가해준다. 위와 같이 ‘public static void main(String[] args)’ 부분에 체크해주면 된다. 메인 메소드는 하나의 프로그램 안에 여러 개의 클래스가 공존할 때 가장 첫 번째로 실행되는 부분을 정해주기 위해 사용한다. 이후에 클래스가 생성되면 다음과 같이 코드를 작성한다
     >
     >  위 소스코드는 방금 우리가 작성해준 SHA-256 해시 값을 구하는 함수 getHash()를 사용해서 결과를 확인하는 간단한 형태의 소스코드다. 구체적으로 문자열 “0”에 대한 SHA-256 해시 결과를 출력하도록 하였다. 이제 실행 버튼(F11)을 눌러 프로그램을 동작시켜보자.
     >
     > 프로그램 실행 결과는 위와 같다. 총 64글자의 16진수 데이터가 출력된 것을 확인할 수 있다. 그 결과는 ‘5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9’로 이해할 수 없는 무작위의 문자열이다. 이제 한 번 문자열 “0” 대신에 “1”을 넣어서 다시 실행해보자.
     >
     > 실행 결과로 ‘6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b’가 출력된 것을 확인할 수 있다. 이는 앞서 문자열 “0”을 넣었을 때와 비교하여 완전히 다른 결과 값이 출력되었다. 이와 같이 SHA-256 해시 알고리즘은 눈사태 효과(Avalanche Effect) 기법이 적용되어 입력 값에 따른 결과 값을 유추할 수 없고 천차만별이다. 따라서 결과 값을 보고 입력 값이 무엇이었는지 정확히 알아내기 매우 어렵다. 우연의 일치로 맞출 확률 또한 매우 희박하다.
     >
     >   블록체인에서 사용되는 채굴의 원리는 이러한 눈사태 효과에서 출발한다. 간단한 작업 증명(Proof of Work) 채굴 방식을 소스코드로 구현해보자. 현재 한 글자는 16진수를 의미하므로 2^4 = 16가지 경우의 수를 표현할 수 있다. 그렇다면 작업 난이도를 2^24라고 가정해보자. 쉽게 말해 2^24번 채굴을 시도했을 때 한 번 정도 채굴이 될 수 있도록 난이도를 설정한다는 것이다.
     >
     > 위 소스코드는 임의의 입력 값에 대해서 SHA-256을 적용한 결과 값이 앞에서부터 6자리만큼 모두 문자 ‘0’으로 구성되어있는지 물어보고, 만약 6자리가 모두 ‘0’으로 구성되어 있다면 정답을 찾았다고 출력하는 소스코드다. 6자리가 모두 0일 확률은 2^4를 6번 곱한 수의 역수이므로 1 / 2^24다. 따라서 확률적으로 대략 천만 번 이상의 연산을 수행했을 때 한 번 채굴에 성공할 수 있는 것이다. 실제로 위 프로그램을 작동시키면 수 초 후에 다음과 같은 결과가 출력된다.
     >
     > 실제 대부분의 작업 증명 합의 알고리즘을 사용하는 블록체인 시스템은 위와 같이 무작위의 입력 갑을 대입하여 정답(Nonce) 과정으로 채굴(Mining)을 진행하도록 설계되어 있다. 현재 우리는 난이도를 2^24로 설정했으나 실제 블록체인 채굴 난이도는 이것보다 훨씬 어렵다는 점에서 고성능의 컴퓨터 연산이 필요한 것이다. 이번 시간에는 간단히 SHA-256 함수를 직접 구현해봄으로써 채굴이 이루어지는 과정에 대해서 이해하는 시간을 가졌다. 이와 같이 해시 값 생성 함수는 블록체인 소프트웨어에서 가장 핵심이 되면서 중요한 기능이다.

  3. 블록(Block) 클래스를 생성

     > 바로 이전 시간에 이어서 core 패키지 안에 새로운 클래스(Class)를 생성해준다. 클래스 이름은 Block으로 이 클래스는 하나의 블록에 대한 정보를 담고 처리하는 역할을 수행
     >
     > 위 소스코드에서 볼 수 있듯이 블록(Block) 클래스는 내부적으로 블록 번호(Block ID), 정답 값(Nonce), 데이터(Data)라는 세 개의 변수를 가지고 있다. 그리고 getInformation()이라는 메소드를 구현하여 현재 특정한 블록이 가지는 정보를 출력할 수 있도록 해주었다. 이제 이렇게 정의한 블록 클래스를 실제로 사용해보기 위해 BlockChainStarter 클래스의 소스코드를 수정해보자.
     >
     > 위 소스코드는 블록 번호가 ‘1’이고, 정답 값이 ‘0’이며 블록이 포함하고 있는 데이터가 ‘데이터’인 하나의 블록을 생성한 뒤에 그 블록에 대한 정보를 출력한다. 작성 이후에 이클립스(Eclipse)의 실행(F11) 버튼을 눌러 프로그램을 동작시키면 다음과 같은 결과가 출력된다.
     >
     > 위와 같이 우리가 임의로 만들어 본 블록에 대한 정보가 성공적으로 출력되는 것을 알 수 있다. 이제 특정한 블록을 대상으로 하여 채굴(Mining)을 수행하는 메소드를 작성해보자. Block 클래스 내부에 다음과 같은 메소드를 추가해준다.

     

* Consensus Algorithms

  1. 컨센서스(Consensus)는 무엇인가?

     > 블록체인의 데이터는 중앙화된 서버 대신 전세계에 흩어져 있는 수많은 노드(Node)에 보관되기 때문에 각각의 노드들은 블록에 기록하는 데이터가 위변조되지 않은 원본이라는 것을 상호간에 합의하는 과정이 필요.
     >
     > 만약 블록을 생성하는 특정 노드가 악의를 품고 조작된 데이터를 저장하거나 네트워크에 전파한다면 시스템 전체의 신뢰도가 떨어지게 됨.
     >
     > 이런 악의적인 상황이 발생하더라도 네트워크를 올바른 방향으로 이끌고자하는 다수의 노드들이 상호 검증을 거쳐 올바른 블록 생성을 이끌어내는 프로세스와 알고리즘을 바로 컨센서스(합의)라고 함.
     >
     > 컨센서스는 블록체인에서 가장 중요한 개념 중 하나이기 때문에, 어떤 컨센서스 알고리즘을 사용하는지는 블록체인의 기술력과 경쟁력으로 여겨지기도 함.

  2. 컨센서스(Consensus)의 종류에는 무엇이 있는가?

     * PoW (Proof-of-Work) : 작업증명

       > PoW는 최초의 블록체인인 비트코인을 창시한 Satoshi Nakamoto가 제안한 컨센서스입니다. 영문 뜻 그대로 "작업증명" 방식으로 불리는데, 블록 생성 시간동안 가장 많은 해시파워를 제공한 노드가 블록을 생성할 수 있도록 설계가 되어 있습니다. 해시파워를 만드는 과정은 채굴 또는 마이닝(Mining)이라고 부르는데, 컴퓨팅 파워를 통해 블록체인 네트워크에 전송된 암호화된 거래정보를 푼 뒤, 새로운 블록을 체인에 연결하는 작업을 하는 것을 의미합니다.
       >
       > 작업증명은 가장 먼저 나온 컨센서스 알고리즘이며 암호화폐 시장 초기에는 가장 보편화되어 있는 컨센서스 알고리즘이기도 했습니다. 비트코인 계열이라고 할 수 있는 비트코인 캐시, 비트코인 골드, 라이트코인 등도 이 방식을 사용하고 있습니다. PoW에서는 브랜치가 생긴 경우 가장 긴 블록체인이 남을 때까지 서로 경쟁하여 이긴 브랜치가 최종적인 브랜치로 채택이 되며, 다른 브랜치는 버려지도록 설계되었습니다.

       * 장점(pros)

         > 현재 높은 시장 가치를 형성하고 있는 주류 코인들이 채택하고 있습니다.
         >
         > PoW 컨센서스 채택 코인 : 비트코인, 비트코인 캐시, 비트코인 골등 라이트코인 등 (이더리움은 PoW에서 PoS로 변경 작업 중에 있음)
         >
         > 강력한 보안성을 제공합니다.
         >
         > 서비스 남용을 쉽게 방지할 수 있습니다.

       * 단점(cons)

         > 높은 전력소모를 통해 자원을 낭비합니다.
         >
         > 지속적으로 해시파워를 유지해야 합니다.
         >
         > 특정 마이닝 세력의 해시 독점으로 인한 생태계(ecosystem)의 교란 우려가 있습니다.

     * PoS (Proof-of-Stake) : 지분증명

       > PoS는 코인을 보유한 지분율에 따라 새롭게 생성하는 코인을 분배받는 방식의 컨센서스 알고리즘입니다. 영문 뜻 그대로 "지분증명"방식으로 불립니다. PoW와는 다르게 일정 수 이상의 코인을 보관하고 있는 지갑을 블록체인 네트워크에 연결시켜 놓기만 하면 보상을 받을 수 있습니다. 보상의 경우, PoW와 마찬가지로 블록이 생성될 때 보상이 지급되는데 차이점은 이자와 같은 방식으로 코인이 지급된다는 것이 차이점입니다.
       >
       > PoS 컨센서스 알고리즘을 채택한 1세대 코인으로는 대표적으로 NXT가 있으며, 현재는 다양한 코인들이 PoS방식을 채택하고 있는 추세입니다.PoS는 지분을 많이 가지고 있는 노드에게 블록을 생성할 권한을 줍니다. 블록 생성자와 지분 생성자의 이해관계를 일치시킴으로써 블록을 나쁜 의도로 생성할 동기부여를 없애며, 잘못 생성할 경우 패널티를 부여합니다.

       * 장점(pros)

         > 해시파워가 많이 필요하지 않으므로 경제적이고 친환경적입니다.
         >
         > PoW방식은 채굴노드가 하드웨어를 직접적으로 갖춰야 하고 에너지 소모가 굉장히 크며, 대량의 채굴기를 돌리기 위해서는 지리적으로 최적화된 입지를 확보해야 합니다. (채굴기 자체에서 발생하는 열과 소음이 상당합니다.)
         >
         > 블록 생산자의 탈중앙화로 안정성을 확보할 수 있습니다.
         >
         > PoW에서 51%의 해시파워를 가지는 비용 = 약 1조
         >
         > PoS에서 51%의 전세계 자산을 가지는 비용 = 약 100조
         >
         > 블록을 생성하기 위해 지분을 담보로 잡아야하기 때문에 덤핑을 방지할 수 있습니다.

       * 단점(cons)

         > 보안성이 강한지에 대한 여부가 아직까지 정확히 검증되지 않았습니다.
         >
         > 지분이 많은 이른바 고래(Whale)들이 권력을 독점할 가능성이 존재합니다.
         >
         > 일반적으로는 해당 코인을 발행한 개발진들이 고래들의 권력 독점을 방지하기 위해서 시중에 발행하는 코인의 비율을 조절하기 때문에 특정 고래가 권력을 독점하는 것은 현실적으로 불가능에 가깝습니다.

     * DPoS (Delegated Proof-of-Stake) : 위임된 지분증명

       > DPoS는 PoS 컨센서스 알고리즘을 변형한 형태로 위임된 지분증명 방식을 말합니다. 모든 노드의 자격을 가진 주주들이 블록생성에 참여하는 방식(PoS방식) 대신에 네트워크의 모든 노드의 투표 결과로 선출한 상위 노드(이를 증인* 또는 Witness라고 일컫습니다.)에게 권한을 위임하여 합의하도록 하는 방식입니다. 일정 수의 증인들은 모든 권한을 위임 받아 블록 생성을 담당합니다. PoS방식이 직접민주주의 방식이라면, DPoS는 간접민주주의 방식이라고 할 수 있습니다.
       >
       > 권한을 위임 받아 블록생성을 담당하는 "증인"은 Steem의 경우 20명, EOS의 경우 21명입니다.
       >
       > EOS의 개발자인 댄 라리머는 DPoS 컨센서스를 사용하는 그리핀(Graphene)엔진을 토대로 Steem과 Bitshare를 만들고 이에 대한 성능을 검증한 바 있습니다. DPoS는 합의에 참여하는 노드의 수가 한정되어 있기 때문에 매우 빠른 성능과 확장성을 보여주고 있지만, 완전히 탈중앙화된 블록체인이 아니라는 비판을 받기도 합니다.

       * 장점(pros)

         > PoS에 비해 많은 트랜잭션을 빠르게 처리할 수 있습니다.
         >
         > PoW에 비해 비용이 낮습니다.
         >
         > 하드포크의 위험이 낮습니다.
         >
         > 증인들이 투표에 참여할 인센티브가 분명합니다.

       * 단점(cons)

         > 증인끼리 담합할 위험이 존재합니다.
         >
         > 공개된 소수의 증인에 대한 디도스(DDoS)공격 위험이 있습니다.
         
         
         
         

# 6월 10일 10일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 10일차 (6/10) | 조원철 | 3.0 블록체인 최종 코드 |

         
       
#### 3.0 블록체인 최종 코드
         
         
* Block.java

  > 블록체인에 연결되는 블록

  ```java
  import java.util.ArrayList;
  import java.util.Date;
  
  public class Block {
  	
  	public String hash;
  	public String previousHash;
  	public String merkleRoot;
  	public ArrayList<Transaction> transactions = new ArrayList<Transaction>(); //out data will be a simple message.
  	//private String data; //our data will be a simple message.
  	private long timeStamp; //as number of milliseconds since 1/1/1970.
  	private int nonce;
  	
  	public Block(String previousHash) {
  		this.previousHash = previousHash;
  		this.timeStamp = new Date().getTime();
  		this.hash = calculateHash();
  	}
  	
  	//Calculate new hash based on blocks contents
  	public String calculateHash() {
  		String calculatedhash = StringUtil.applySha256( 
  				previousHash +
  				Long.toString(timeStamp) +
  				Integer.toString(nonce) + 
  				merkleRoot
  				);
  		return calculatedhash;
  	}
  	
  	public void mineBlock(int difficulty) {
  		merkleRoot = StringUtil.getMerkleRoot(transactions);
  		//String target = new String(new char[difficulty]).replace('\0', '0'); //Create a string with difficulty * "0" 
  		String target = StringUtil.getDificultyString(difficulty);
  		while(!hash.substring( 0, difficulty).equals(target)) {
  			nonce ++;
  			hash = calculateHash();
  		}
  		System.out.println("Block Mined!!! : " + hash);
  	}
  	
  	//Add transactions to this block
  	public boolean addTransaction(Transaction transaction) {
  		//process transaction and check if valid, unless block is genesis block then ignore.
  		if(transaction == null) return false;
  		if((previousHash != "0")) {
  			if((transaction.processTransaction() != true)) {
  				System.out.println("Transaction failed to process. Discarded.");
  				return false;
  			}
  		}
  		transactions.add(transaction);
  		System.out.println("Transaction Successfully added to Block");
  		return true;
  	}
  }
  ```

  

* NoobChain.java

  > Block을 생성하고 연결시키는 부분 - 블록체인을 생성하는 Main

  ```java
  import java.security.Security;
  import java.util.ArrayList;
  import java.util.HashMap;;;
  
  public class NoobChain {
  
  	public static ArrayList<Block> blockchain = new ArrayList<>();
  	public static int difficulty = 5;
  
  	// 지갑 추가
  	public static Wallet walletA;
  	public static Wallet walletB;
  
  	// 블록헤더 - UTXO의 모음
  	public static HashMap<String, TransactionOutput> UTXOs = new HashMap<>();
  
  	public static float minimumTransaction = 0.1f;
  
  	public static Transaction genesisTransaction;
  
  	public static void main(String[] args) {
  		// Setup Bouncey castle as a Security Provider
  		Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
  
  		// Create the new wallets
  		walletA = new Wallet();
  		walletB = new Wallet();
  		Wallet coinbase = new Wallet();
  
  		// create genesis transaction, which sends 100 NoobCoin to walletA:
  		genesisTransaction = new Transaction(coinbase.publicKey, walletA.publicKey, 100f, null);
  		genesisTransaction.generateSignature(coinbase.privateKey); // manually sign the genesis transaction
  		genesisTransaction.transactionId = "0"; // manually set the transaction id
  		genesisTransaction.outputs.add(new TransactionOutput(genesisTransaction.reciepient, genesisTransaction.value,
  				genesisTransaction.transactionId)); // manually add the Transactions Output
  		UTXOs.put(genesisTransaction.outputs.get(0).id, genesisTransaction.outputs.get(0)); // its important to store
  																							// our first transaction in
  																							// the UTXOs list.
  
  		System.out.println("Creating and Mining Genesis block... ");
  		Block genesis = new Block("0");
  		genesis.addTransaction(genesisTransaction);
  		addBlock(genesis);
  
  		// testing
  		Block block1 = new Block(genesis.hash);
  		System.out.println("\nWalletA's balance is: " + walletA.getBalance());
  		System.out.println("\nWalletA is Attempting to send funds (40) to WalletB...");
  		block1.addTransaction(walletA.sendFunds(walletB.publicKey, 40f));
  		addBlock(block1);
  		System.out.println("\nWalletA's balance is: " + walletA.getBalance());
  		System.out.println("WalletB's balance is: " + walletB.getBalance());
  
  		Block block2 = new Block(block1.hash);
  		System.out.println("\nWalletA Attempting to send more funds (1000) than it has...");
  		block2.addTransaction(walletA.sendFunds(walletB.publicKey, 1000f));
  		addBlock(block2);
  		System.out.println("\nWalletA's balance is: " + walletA.getBalance());
  		System.out.println("WalletB's balance is: " + walletB.getBalance());
  
  		Block block3 = new Block(block2.hash);
  		System.out.println("\nWalletB is Attempting to send funds (20) to WalletA...");
  		block3.addTransaction(walletB.sendFunds(walletA.publicKey, 20));
  		System.out.println("\nWalletA's balance is: " + walletA.getBalance());
  		System.out.println("WalletB's balance is: " + walletB.getBalance());
  
  		isChainValid();
  	}
  
  	public static Boolean isChainValid() {
  		Block currentBlock;
  		Block previousBlock;
  		String hashTarget = new String(new char[difficulty]).replace('\0', '0');
  
  		HashMap<String, TransactionOutput> tempUTXOs = new HashMap<String, TransactionOutput>(); // a temporary working
  																									// list of unspent
  																									// transactions at a
  																									// given block
  																									// state.
  		tempUTXOs.put(genesisTransaction.outputs.get(0).id, genesisTransaction.outputs.get(0));
  
  		// loop through blockchain to check hashes:
  		for (int i = 1; i < blockchain.size(); i++) {
  			currentBlock = blockchain.get(i);
  			previousBlock = blockchain.get(i - 1);
  			// compare registered hash and calculated hash:
  			if (!currentBlock.hash.equals(currentBlock.calculateHash())) {
  				System.out.println("Current Hashes not equal");
  				return false;
  			}
  			// compare previous hash and registered previous hash
  			if (!previousBlock.hash.equals(currentBlock.previousHash)) {
  				System.out.println("Previous Hashes not equal");
  				return false;
  			}
  			// check if hash is solved
  			if (!currentBlock.hash.substring(0, difficulty).equals(hashTarget)) {
  				System.out.println("This block hasn't been mined");
  				return false;
  			}
  
  			// loop thru blockchains transactions:
  			TransactionOutput tempOutput;
  			for (int t = 0; t < currentBlock.transactions.size(); t++) {
  				Transaction currentTransaction = currentBlock.transactions.get(t);
  
  				if (!currentTransaction.verifySignature()) {
  					System.out.println("#Signature on Transaction(" + t + ") is Invalid");
  					return false;
  				}
  				if (currentTransaction.getInputsValue() != currentTransaction.getOutputsValue()) {
  					System.out.println("#Inputs are note equal to outputs on Transaction(" + t + ")");
  					return false;
  				}
  
  				for (TransactionInput input : currentTransaction.inputs) {
  					tempOutput = tempUTXOs.get(input.transactionOutputId);
  
  					if (tempOutput == null) {
  						System.out.println("#Referenced input on Transaction(" + t + ") is Missing");
  						return false;
  					}
  
  					if (input.UTXO.value != tempOutput.value) {
  						System.out.println("#Referenced input Transaction(" + t + ") value is Invalid");
  						return false;
  					}
  
  					tempUTXOs.remove(input.transactionOutputId);
  				}
  
  				for (TransactionOutput output : currentTransaction.outputs) {
  					tempUTXOs.put(output.id, output);
  				}
  
  				if (currentTransaction.outputs.get(0).reciepient != currentTransaction.reciepient) {
  					System.out.println("#Transaction(" + t + ") output reciepient is not who it should be");
  					return false;
  				}
  				if (currentTransaction.outputs.get(1).reciepient != currentTransaction.sender) {
  					System.out.println("#Transaction(" + t + ") output 'change' is not sender.");
  					return false;
  				}
  
  			}
  
  		}
  		System.out.println("Blockchain is valid");
  		return true;
  	}
  
  	public static void addBlock(Block newBlock) {
  		newBlock.mineBlock(difficulty);
  		blockchain.add(newBlock);
  	}
  }
  
  ```

  

* StringUtil.java

  > 블록을 만들고 해시화하는 과정에 필요한 util 부분을 모아놓은 부분

  ```java
  import java.security.Key;
  import java.security.MessageDigest;
  import java.security.PrivateKey;
  import java.security.PublicKey;
  import java.security.Signature;
  import java.util.ArrayList;
  import java.util.Base64;
  
  public class StringUtil {
  	//Applies Sha256 to a string and returns the result. 
  	public static String applySha256(String input){		
  		try {
  			MessageDigest digest = MessageDigest.getInstance("SHA-256");	        
  			//Applies sha256 to our input, 
  			byte[] hash = digest.digest(input.getBytes("UTF-8"));	        
  			StringBuffer hexString = new StringBuffer(); // This will contain hash as hexidecimal
  			for (int i = 0; i < hash.length; i++) {
  				String hex = Integer.toHexString(0xff & hash[i]);
  				if(hex.length() == 1) hexString.append('0');
  				hexString.append(hex);
  			}
  			return hexString.toString();
  		}
  		catch(Exception e) {
  			throw new RuntimeException(e);
  		}
  	}
  	
  	public static byte[] applyECDSASig(PrivateKey privateKey, String input) {
  		Signature dsa;
  		byte[] output = new byte[0];
  		try {
  			dsa = Signature.getInstance("ECDSA","BC");
  			dsa.initSign(privateKey);
  			byte[] strByte = input.getBytes();
  			dsa.update(strByte);
  			byte[] realSig = dsa.sign();
  			output = realSig;
  		} catch(Exception e ) {
  			throw new RuntimeException(e);
  		}
  		
  		return output;
  	}
  	
  	public static boolean verifyECDSASig(PublicKey publicKey, String data, byte[] signature) {
  	
  		try {
  			Signature ecdsaVerify = Signature.getInstance("ECDSA", "BC");
  			ecdsaVerify.initVerify(publicKey);
  			ecdsaVerify.update(data.getBytes());
  			return ecdsaVerify.verify(signature);
  		} catch(Exception e) {
  			throw new RuntimeException(e);
  		}
  		
  	}
  
  	public static String getStringFromKey(Key key) {
  		return Base64.getEncoder().encodeToString(key.getEncoded());
  	}
  	
  	//Returns difficulty string target, to compare to hash. eg difficulty of 5 will return "00000"  
  	public static String getDificultyString(int difficulty) {
  		return new String(new char[difficulty]).replace('\0', '0');
  	}
  	
  	public static String getMerkleRoot(ArrayList<Transaction> transactions) {
  		int count = transactions.size();
  		ArrayList<String> previousTreeLayer = new ArrayList<String>();
  		for(Transaction transaction : transactions) {
  			previousTreeLayer.add(transaction.transactionId);
  		}
  		ArrayList<String> treeLayer = previousTreeLayer;
  		while(count > 1) {
  			treeLayer = new ArrayList<String>();
  			for(int i=1; i < previousTreeLayer.size(); i++) {
  				treeLayer.add(applySha256(previousTreeLayer.get(i-1) + previousTreeLayer.get(i)));
  			}
  			count = treeLayer.size();
  			previousTreeLayer = treeLayer;
  		}
  		String merkleRoot = (treeLayer.size() == 1) ? treeLayer.get(0) : "";
  		return merkleRoot;
  	}
  }
  ```

  

* Transaction.java

  > 트랜잭션에 대한 정보를 담아놓은 클래스

  ```java
  import java.security.*;
  import java.util.ArrayList;
  
  public class Transaction {
  	public String transactionId;	//this is also the hash of the transaction.
  	public PublicKey sender;	//sneders address/public key.
  	public PublicKey reciepient; //Recipients address/public key.
  	public float value;
  	public byte[] signature;	//this is to prevent anybody else from spending funds in out wall
  	
  	public ArrayList<TransactionInput> inputs = new ArrayList<>();
  	public ArrayList<TransactionOutput> outputs = new ArrayList<>();
  	
  	private static int sequence = 0; // a rough count of how many transactions have been generation
  	
  	//Constructor
  	public Transaction(PublicKey from, PublicKey to, float value, ArrayList<TransactionInput> inputs) {
  		this.sender = from;
  		this.reciepient = to;
  		this.value = value;
  		this.inputs = inputs;
  	}
  	
  	//This Calculates the transaction hash (which will be used as its Id)
  	private String calulateHash() {
  		sequence++;	//increase the sequence to avoid 2 identical transactions having the sa..
  		return StringUtil.applySha256(
  					StringUtil.getStringFromKey(sender) +
  					StringUtil.getStringFromKey(reciepient) +
  					Float.toString(value) + sequence
  				
  				);
  	}
  	
  	public void generateSignature(PrivateKey privateKey) {
  		String data = StringUtil.getStringFromKey(sender) + StringUtil.getStringFromKey(reciepient) + Float.toString(value);
  		signature = StringUtil.applyECDSASig(privateKey, data);
  	}
  	
  	public boolean verifySignature() {
  		String data = StringUtil.getStringFromKey(sender) + StringUtil.getStringFromKey(reciepient) + Float.toString(value);
  		return StringUtil.verifyECDSASig(sender, data, signature);
  	}
  	
  	public boolean processTransaction() {
  		if(verifySignature() == false) {
  			System.out.println("#Transaction Signature failed to verify");
  			return false;
  		}
  		
  		//gather transaction inputs (Make sure they are unspent):
  		for(TransactionInput i : inputs) {
  			i.UTXO = NoobChain.UTXOs.get(i.transactionOutputId);
  		}
  		
  		//check if transaction is valid:
  		if(getInputsValue() < NoobChain.minimumTransaction) {
  			System.out.println("#Transaction Inputs to small: " + getInputsValue());
  			return false;
  		}
  		
  		//generate transaction outputs:
  		float leftOver = getInputsValue() - value; //get value of inputs then the left over change:
  		transactionId = calulateHash();
  		outputs.add(new TransactionOutput(this.reciepient, value, transactionId)); //send value to recipient
  		outputs.add(new TransactionOutput(this.sender, leftOver, transactionId)); //send the left over 'change' back to sender
  		
  		//add outputs to Unspent list
  		for(TransactionOutput o : outputs) {
  			NoobChain.UTXOs.put(o.id, o);
  		}
  		
  		//remove transaction inputs from UTXO lists as spent:
  		for(TransactionInput i : inputs) {
  			if(i.UTXO == null) continue; //if Transaction can't be found skip it
  			NoobChain.UTXOs.remove(i.UTXO.id);
  		}
  		
  		return true;
  	}
  	
  	//returns sum of inputs(UTXOs) values
  	public float getInputsValue() {
  		float total = 0;
  		for(TransactionInput i : inputs) {
  			if(i.UTXO == null) continue; //if Transaction can't be found skip it
  			total += i.UTXO.value;
  		}
  		return total;
  	}
  	
  	//returns sum of outputs:
  	public float getOutputsValue() {
  		float total = 0;
  		for(TransactionOutput o : outputs) {
  			total += o.value;
  		}
  		return total;
  	}
  	
  }
  ```

  

* TransactionInput.java

  ```java
  
  public class TransactionInput {
  	
  	public String transactionOutputId;
  	public TransactionOutput UTXO;
  	
  	public TransactionInput(String transactionOutputId) {
  		this.transactionOutputId = transactionOutputId;
  	}
  	
  }
  
  ```

  

* TransactionOutput.java

  ```java
  import java.security.PublicKey;
  
  public class TransactionOutput {
  	public String id;
  	public PublicKey reciepient;
  	public float value;
  	public String parentTransactionId;
  	
  	public TransactionOutput(PublicKey reciepient, float value, String parentTransactionId) {
  		this.reciepient = reciepient;
  		this.value = value;
  		this.parentTransactionId = parentTransactionId;
  		this.id = StringUtil.applySha256(StringUtil.getStringFromKey(reciepient)+Float.toString(value)+parentTransactionId);
  	}
  	
  	public boolean isMine(PublicKey publicKey) {
  		return (publicKey == reciepient);
  	}
  }
  
  ```

  

* Wallet.java

  > 사용자에게 제공되는 Wallet 부분 => 개인키, 공개키를 포함하고 있다.

  ```java
  import java.security.KeyPair;
  import java.security.KeyPairGenerator;
  import java.security.PrivateKey;
  import java.security.PublicKey;
  import java.security.SecureRandom;
  import java.security.spec.ECGenParameterSpec;
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.util.Map;
  
  public class Wallet {
  
  	public PrivateKey privateKey; // 개인키
  	public PublicKey publicKey; // 공개키
  
  	public HashMap<String, TransactionOutput> UTXOs = new HashMap<String, TransactionOutput>();
  
  	public Wallet() {
  		generateKeyPair();
  	}
  
  	public void generateKeyPair() {
  		try {
  			KeyPairGenerator keyGen = KeyPairGenerator.getInstance("ECDSA", "BC");
  			SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
  			ECGenParameterSpec ecSpec = new ECGenParameterSpec("prime192v1");
  
  			// Initialize the key generator and generate a KeyPair
  			keyGen.initialize(ecSpec, random);
  			KeyPair keyPair = keyGen.generateKeyPair();
  
  			// Set the public and private keys from the keyPair
  			privateKey = keyPair.getPrivate();
  			publicKey = keyPair.getPublic();
  		} catch (Exception e) {
  			// TODO Auto-generated catch block
  			e.printStackTrace();
  		}
  
  	}
  
  	public float getBalance() {
  		float total = 0;
  		for (Map.Entry<String, TransactionOutput> item : NoobChain.UTXOs.entrySet()) {
  			TransactionOutput UTXO = item.getValue();
  			if (UTXO.isMine(publicKey)) { // if output belongs to me ( if coins belong to me )
  				UTXOs.put(UTXO.id, UTXO); // add it to our list of unspent transactions.
  				total += UTXO.value;
  			}
  		}
  		return total;
  	}
  
  	public Transaction sendFunds(PublicKey _recipient, float value) {
  		if (getBalance() < value) {
  			System.out.println("#Not Enough funds to send transaction. Transaction Discarded.");
  			return null;
  		}
  		ArrayList<TransactionInput> inputs = new ArrayList<TransactionInput>();
  
  		float total = 0;
  		for (Map.Entry<String, TransactionOutput> item : UTXOs.entrySet()) {
  			TransactionOutput UTXO = item.getValue();
  			total += UTXO.value;
  			inputs.add(new TransactionInput(UTXO.id));
  			if (total > value)
  				break;
  		}
  
  		Transaction newTransaction = new Transaction(publicKey, _recipient, value, inputs);
  		newTransaction.generateSignature(privateKey);
  
  		for (TransactionInput input : inputs) {
  			UTXOs.remove(input.transactionOutputId);
  		}
  
  		return newTransaction;
  	}
  }
  
  ```

  