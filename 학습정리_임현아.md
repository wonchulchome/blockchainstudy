# 5월 28일 2일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 2일차 (5/28) | 임현아 | 1.1 비트코인 암호 기초<br />1.2 비트코인이란<br />1.3 비트코인 네트워크 기초 |



## 주요 내용 요약

#### 1.1 비트코인 암호 기초

- ##### 해시함수

  > 어떤 메세지에 대해 짧고 일정한 길이 (128 ~ 512) 의 메세지를 반환하는 함수
 
  1. **일방향성**

     > 메세지(M)과 함수(H)를 통해 나온 값(H(M)) 은 1:1 관계를 갖는다.

  2. **역상 저항성**

     > H(X) = V 에서 V로 X를 찾을 수 없다. => 역함수를 구할 수 없다.

  3. **임의성**

     > 메세지(M) 값이 조금만 달라져도 완전히 다른 값이 생성된다.

- ##### 공개키 암호

  > 암호화에 사용하는 키를 두 개 생성한 후, 그 중 한 개는 **공개(public)**, 다른 한 개는 **비밀(private)** 로 보관
  > `공개 => 공개키`, `비밀 => 개인키`

  * **공개키(K+)** : 주소 생성과 서명 검증 => 공인 인증서와 같은 방식으로 누구나 볼 수 있다.
  * **개인키(K-)** : 서명 생성 => 개인만의 고유한 키로 다른 사람을 알 수 없다.
  * 일반적으로 개인키를 사용하여 암호화를 진행 후, 공개키를 사용하여 복호화를 한다.

- ##### 서명

  > 메세지를 보낼 때, 누가 보내는 지를 함께 보내기 위한 방법

  * **서명 생성**
    * 개인키를 사용하여 메세지(M)의 해시값(H(M))을 암호화
    * 메세지(M)와 서명(E(H(M), K-))을 전송한다.
      => 서명을 생성할 때, 어떤 메세지와 보내는 지(H(M)), 누가 보내는 지(K-)를 E로 묶어 생성한다.
    * `M + E(H(M), K-)` 형태로 전송
  * **서명 검증**
    * 수신한 `M + E(H(M), K-)` 를 다음과 같이 검증한다.
      1. `M`을 해시함수를 사용하여 `H(M)` 형태로 만든다.
      2. `E(H(M), K-)` 를 공개된 `K+`와 복호화(DE) 과정을 거쳐 H(M) 형태만 남긴다.
         `DE(E(H(M), K-), K+)` => `H(M)`
      3. *1*, *2* 의 결과 값이 같은지를 검증한다.
  * 활용
    * 거래 생성자 확인
    * 특정 주소의 코인 소유자 확인



#### 1.2 비트코인이란?

* ##### 비트코인(BTC)

  * 비트코인 네트워크에서 발행되는 통화의 이름
  * 비트코인 통화가 운영되는 네트워크 시스템 전체
    * 블록체인 (거래장부 - 트랜잭션이 담긴 블록을 체인으로 엮은 것)
    * 블록 전송을 위한 네트워크
    * 블록체인을 생성하고 검증하는 채굴자 집합


* ##### 비트코인의 출현

  * P2P 전자화폐 시스템
  * 공개키 기반의 주소에 대응되는 서명에 의한 증명
    

* ##### 비트코인의 특징

  * 모든 지불 거래 정보를 블록체인에 저장
  * 블록체인에서 승인된 거래 기록 변경 불가
  * 누구나 블록체인 생성에 참여 가능
  * 누구나 블록체인 유지 및 내역 확인 가능
  * Legder(원장 - 거래 승인, 전자 화폐 이동) 관리
  * 이중 지불 불가



#### 1.3 비트코인 네트워크 기초

* ##### 기존 금융 네트워크

  * 중앙기관에 의해 구축, 운영
  * 클라이언트 - 서버 네트워크

* ##### 비트코인 네트워크

  * 운영주체가 없이 참여자들이 자발적으로 구축, 운영
  * 참여자들의 컴퓨터를 연결한 P2P 네트워크
  * 누구든지 (node)로 참여가 가능 - 채굴, 거래소 등
  * 참여를 통한 인센티브로 비트코인을 제공.

* ##### 네트워크의 익명성

  * 암호학적으로 생성되는 비트코인의 주소를 사용하므로, 사용자가 누구인지 바인딩 하는 과정을 존재하지 않아 익명성이 보장됨

* ##### 비정상적인 참여자 존재 가능

  * 누구나 참여가 가능하므로, 불안정하고 속도가 느린 부실한 컴퓨터나, 악의적 사용자가 운연하는 악성 컴퓨터 노드가 존재할 수 있다.
  




---
  

# 5월 29일 3일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 3일차 (5/29) | 임현아 | 1.4 비트코인 전자화폐 거래개념 <br />1.5 비트코인 블록체인 개요 |


#### 1.4 비트코인 전자화폐 거래개념

- ##### 거래의 목표

  - P2P 거래

    > 모든 거래는 당사자간에 P2P방식으로 이루어짐

  - 안전하고 투명한 거래 

    > 모든 지불 거래 내역이 public ledger인 블록체인에 기록

- ##### 화폐 발행의 주체

  - 채굴자 

    > 블록을 생성, 체인으로 연결하는 참여자

  - `작업 증명 알고리즘` - 채굴 역량에 비례하는 확률로 임의의 채굴자를 자동으로 선정

  - 채굴자가 선정되면, 해당 채굴자의 주소로 블록 보상인 비트코인을 송신하는 거래 내역을 트랜잭션에 기록해 블록 첫번째에 등록 (**CoinBase**)

- ##### 화폐 소유자 증명

  - 소유자 증명 방식

    - 지불 거래 생성시 소유자 증명 방식을 명시한다.
      예.) 수신자 주소에 대응되는 서명 제시를 요구
    - locking script를 unlocking script 로 풀 수 있도록 한다.

- ##### 지불 거래

  - CoinBase 
  

    ![img](https://lh5.googleusercontent.com/74vOXykI7FOfOTFepLd_3_JY3RuY19d2oyhZ8cNZQz2VbqY2LcNkh4-vgKyII_A3ZyOIBSL7FTDQ9T3P9HDfQCdQ-3moz3B0CG6CyrBr-zraCgtlQ2LF_lEZjj_lYR6XwdlmvXUf)
    
    입력값

  - > 해시값 : 출력값에 대한 해시값
    > 서명 : 소유자 증명을 위한 서명

  - 지불 거래
  - 
    ![img](https://lh4.googleusercontent.com/xrn4P7tjsMQU_yckx-szzXeCEmEAUdZ-KyzjphY5QWAgkfNa3IwRHMhX3Mm7KWMfbz9l57oMS8fSltXYs8jtSZAB49SH6IcPKe80LQB9lpYhpx5Ch5Cd3gWxnft9MsyxNtSwABi7)

    - `입력값의 금액 - 출력값의 금액` = 수수료
    - 한번 해시포인터로 지정된 비트코인은 사용이 되었으므로 더이상 사용할 수 없다.
    - 출력값에는 `보내는 금액`, `주소`, `소유자 증명 방식` 기술

  - 지불 거래의 일반적인 형식
  - 
    ![img](https://lh3.googleusercontent.com/FjC0sfzdYRPmj2sEXxD9HUrc57QZ3x1kQ33tYk5En_lVCWHQyv1y41zTCUK8sNgPGWS5a6bfDdMIzHN5Yc0HReQSynXgyYZFY1FtrqBS13kGYS3SLXv6LIbiVEwGVb2gI_BGEuzU)

    - UTXO 

      > 내 주소로 받았는데 아직 사용되지 않은 화폐
      > → 해시포인터로 지정되지 않은 화폐

    - STXO 

      > 받은 화폐중에 이미 사용된 화폐
      > → 해시포인터로 지정이 된 화폐를 의미.

    - 결과적으로,
      블록체인 상의 UTXO의 총합 = 발행된 비트코인의 총액,
      내 지갑의 모든 비트코인의 총액 = 내 주소의 UTXO의 총합.

- 이중 지불 거래 방지

  - 이중 지불이란?

    > STXO를 다시 사용하는 지불거래

  - UTXO 전체 단위로 사용 ⇒ 수신된 비트코인의 일부만 사용하는 것은 불가
    

#### 1.5 비트코인 블록체인 개요

- ##### 블록체인의 역할

  - 비트코인의 지불 거래 정보를 기록한 장부
  - 발행, 이동 내역을 보여주는 장부
  - P2P 거래를 가능하게 하는 원천

- ##### 블록체인의 목표

  - **완전성**

    > 모든 거래를 일관성있게 기록, 누구든지 모든 비트코인의 현황을 확인할 수 있다.

  - **안전성**

    > 비정산 거래 기록 불가, 승인된 거래 변경/교체 불가, 블록체인 파괴 불가

  - **분산성 / 비집중성**

    > 누구든지 참여 가능, 의존되지 않으며 일관성이 보장.

  - **투명성**

    > 누구나 블록체인 접근, 검증, 사용 가능.
    > 채굴자가 아니여도 접근 가능 (SPV노드)

- ##### 비트코인 네트워크 참여자

  - 풀 노드 참여자
  - 채굴 노드 참여자
  - SPV 노드

- ##### 비트코인

  - 블록

    > 일정 시간(대략 10분) 동안 교환되는 모든 거래를 검증한 후, 모아서 만든 자료구조 → 장부
    > 생성 후, 모든 네트워크 참여자에게 전달 ⇒ 자신의 블록체인에 수신된 블록을 연결

    - 블록 크기 : 1Mbyte로 제한 (일반적으로 초당 7개의 거래)
      ⇒ 블록 전달 지연시간이 커지는 것을 방지

  - 블록 채굴자 결정

    > PoW (작업증명)에 가장 먼저 성공한 채굴자 ⇒ 그만큼 PC 성능이 좋아야함
    > 예.) 난이도 목표값보다 작은 해시값을 생성하는 넌스

    - 생성한 블록 배포시에 해시값을 포함해, 채굴자가 성공한 것을 누구나 확인 가능하게 함

  - 블록 조작 불가
  
    ![img](https://lh5.googleusercontent.com/07udbAVI70PmgMWszgxASxfPeCCycBHevGbRLRllg7j3YfKh5sN6Zh2HfUmvRnOgjyS_JN4ejuRJqW1_q0Up-eJNBpt5Rc43A-6dc-vtmcPBfMlOqdboa2rZ2ii01AkFuzyH83BB)

  - - **51% Attack** : 51% 이상의 해시파워를 소유한 집단이 공격을 한다면 가능하겠지만, 현실적으로는 불가능하다.

- ##### SPV 노드

  > 블록 헤더(해시 포인터, 난이도 목표, 넌스, 머클 루트) 정보만 유지

  - 머클 트리 : 거래들을 모아놓은 해시 트리
  
    ![img](https://lh5.googleusercontent.com/DlnpEDF7nqEIJev3H9Ccf6klsKq6Ur_Li9tW1cL07ikti3Wx0jurDXLOqRRLr_Px4p_9VXabrIMg6cZT6uOQYT0c3xBX4hpWxOyf9KVBXyb_tLV4jIE5fh3S0QtgP-AC9Vu1Nis9)

  - 머클 경로 : 특정 거래의 존재 증명에 필요한 일련의 해시 노드

    - 거래 k (Hk) 의 머클 경로 ⇒ HI → Hij → Hmnop → Habcdefgh

    - 계산 방법

      > `Hk` + `Hl` ⇒ `Hkl`
      > `Hkl` + `Hij` ⇒ `Hijkl`
      > `Hijkl` +`Hmnop` ⇒ `Hijklmnop`
      > `Hijklmnop` + `Habcdefgh` ⇒ `머클루트`

    - 머클 경로를 사용하면 굳이 머클 트리 전체를 저장할 필요가 없다.

    - 머클 경로의 크기 : log2N

  - SPV 노드의 거래 승인 확인

    - 관심있는 거래의 머클 경로만 다운로드
      해시값 계산 결과와 자신이 보유한 블록 헤더의 머클 루트와 비교




 ---
  

# 5월 30일 4일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 4일차 (5/30) | 임현아 | 1.6 비트코인 스마트거래의 구조 <br />1.7 비트코인 작업증명과 인센티브 |



#### 1.6 비트코인 스마트거래의 구조

* 비트코인 거래(transaction)

  > 참여자들이 비트코인 통화 등 가치를 주고 받고 상호 인정하는 행위를 규정하는 데이터 구조

  * 비트코인 지불 거래

    > **블록체인** 상에서 **입력값(자금원)**에서 **출력값(목적지)** 으로 자금을 전달하는 행위 

    ![img](https://lh3.googleusercontent.com/xm3Guskp8fusCzlTLEF5aBiQtT7UmQL9c1Wv4X96WeCxzlFBPMmZBlNgMKAeFHyJ51j-SkTuVbsr76lnpit1054CPcu0nY_xtFAXbq8RAS-oxbrbdmBV_bpKw9T3dK3MaDkuGx6S)

    ⇒ 입력값 0 : 철수가 가진 자금 (이전 거래의 출력값을 해시포인터로 가르킨다.)
    ⇒ 출력값 0 : 철수가 영희에게 보내는 부분
    ⇒ 출력값 1 : 남은 거스름 돈을 철수에게 보내는 부분

    * 일반적 지불 거래

      >이전 거래의 UTXO를 거래에 사용하므로, 거래에 사용된 자금이 UTXO인지를 확인하기 위해 RAM메모리 풀에 전체 UTXO들을 유지한다. 

    * 거래 수수료 : `입력값 총합 - 출력값 총합` 

  * 자금 분산 거래
  
    ![img](https://lh5.googleusercontent.com/FRKfVU1DqHlSFF7xI9-PjuF6dkFkhrkZKSC0AxeTSgIJjIO9Pmk14v1xSbM4wlZKGXa_gnZjZwxWe7xMN5ZG3x2Ax2QrfBJgYB7JzH5TkYlHMK-wq9mMhJeX8exYMAvtT3UaamcH)

  * 코인베이스 거래

    > 채굴자에게 네트워크가 자동으로 신규 비트코인을 지불하는 거래

    * 출력값 : `금액`, <u>`잠금 스크립트`</u> 로 이루어진다. ⇒  잠금 스크립트 내부에 수신자 포함
      * 잠금 스크립트

        > 해당 출력값을 소비하기 위해 충족시켜야 하는 조건을 기술한 간단한 프로그램

        ```
        예.) scriptPubKey = DUP HASH160 <PubKHash> EQUALVERIFY CHECKSIG
        ```

    * 입력값 : `거래 해시포인터`, `출력값 인덱스`,<u>`해제 스크립트`</u>, `일련번호`

      * 해제 스크립트

        > 서명과 공개키를 데이터로 제공

        ```
        예.) scriptSig = <sig><pubK>
        ```

    * 비트코인 스택 언어 : 거래 실행 - `해제 스크립트` 와 `잠금 스크립트` 의 연결

      ```
      <sig> <pubK> + DUP HASH160 <PubKHash> EQUALVERIFY CHECKSIG
      ```

      > 1. 스택 자료 구조에 해제 스크립트 데이터를 push
      > 2. 명령을 한번씩만 수행 (loop 명령 미지원) - [튜링 불완전 언어]

      * 주요 명령어
        * <data> : 데이터(data)를 스택에 push
        * OP_DUP : top 데이터를 복제한 후 스택에 push
        * OP_HASH160 : pop 한 데이터를 HSA256으로 해싱 ⇒ PEMD160으로 해싱한 결과를 push
        * OP_EQUALVERIFY : 맨 위 두개의 데이터를 pop 하여 같으면 true, 다르면 false를 반환
        * OP_CHECKSIG : 맨 위 공개키와 다음의 서명을 pop, 공개키로 서명을 검증 
          ⇒ 같으면 true, 다르면 false를 반환
        * OP_CHECKMULTISIG : N개의 공개키를 사용, M개의 서명을 검증
          ⇒ 같으면 true, 다르면 false를 반환

      ![img](https://lh3.googleusercontent.com/ezxvsKX2gF8weNunl0hTdSvbmar6pvtJAi8dMwHGXl1jcluWRo79t8HCFJ3-MBhbjCURxl6vbrnxEJ2o7_5APt7ZVxUW6XqURdjTk28-PJbvUL-Tf-8sqE8h7d2ov4hbe0iVI_cv)

  * 특징

    * 거래 조건을 프로그램으로 설정하기 때문에, 다양한 유형의 스마트 거래 개발이 가능하다.

    * 튜링 불완전 언어이기 때문에 복잡한 거래 개발에는 어렵다.

      ⇒ 튜링 완전 언어를 사용하는 화폐는 이더리움



#### 1.7 비트코인 작업증명과 인센티브

* 블록 채굴 정책

  * 목표

    > 채굴자들간에 블록에 대한 합의

  * 수단

    1. 블록 인센티브 정책

       * 블록 보상

         > 블록 채굴에 성공한 채굴자에게 네트워크가 자동으로 지급
         > 시간이 감에 따라 지급량이 축소되도록 설계

       * 거래 수수료

         > 거래 수수료 보상 = `블록의 전체 거래 입력값 총합` - `블록의 전체 거래의 출력값 총합`

       ⇒  코인베이스 거래

       > 블록 채굴에 대한 전체 인센티브는 블록의 첫번째 거래인 코인 베이스 거래에 의해 지불
       > 	출력값 ⇒ `블록 보상` + `거래 수수료`

    2. 작업 증명 정책

       > 블록 헤더에 대한 HSA256 해시값이 목표보다 작아질 때까지 블록 헤더의 일부 값(넌스)를 변경하면서 블록 헤더의 해시값 계산을 반복, 목표보다 작은 값이 발견되면 작업 증명에 성공
       > ⇒ 채굴된 블록을 수신한 다른 채굴자는 블록 헤더의 HSA256 해시값이 목표값보다 작은 지 확인함으로 작업 증명을 검증

       * 블록 헤더 
         `버전` + `해시포인터` + `머클 루트` + `타임스탬프` + `난이도 목표` + `넌스`  로 구성

       * 해시함수 특징

         * 일방향성 

           > 해시값으로부터 원래 데이터를 추론할 수 없음을 보장
           > 따라서, 목표보다 작은 해시값을 정해놓고 거기에 맞는 넌스를 추론하는 것이 불가.

         * 임의성

           > 반복 계산 외의 다른 방법으로 작업 증명을 할 수 없음.

       * 해시율 

         > 해시 함수 적용 능력 = 초당 해시 함수 계산 능력
         > **채굴자의 작업증명 성공 확률** 
         >      = (`채굴자의 해시율`/`전체 채굴자의 해시율 총합`)

  
 ---
  

# 5월 31일 5일차 BlockChain



| 팀           | 구성원         | 일정         | 발제자 | 주제                                                         |
| ------------ | -------------- | ------------ | ------ | ------------------------------------------------------------ |
| **BeatCoin** | 조원철, 임현아 | 5일차 (5/31) | 임현아 | 2.1 자바를 사용하여 기본적인 블록체인 만들기 <br />2.2 PoW(Proof of Work) 알고리즘 구현하기 |



#### 2.1 자바를 사용하여 기본적인 블록체인 만들기

* ##### 블록체인 만들기

  > 기본적인 블록체인을 만들기 위해서 필요한 구조는 다음과 같다.
  >
  > * 블록 : `이전 블록의 해시값`, `현재의 해시값`, `데이터`, `생성된 시간`, `증명에 필요한 nonce` 로 이루어짐
  > * util : 블록을 생성할 때 필요한 util 모음
  > * 블록체인 : 블록을 연결하는 Main 클래스

  

  * 블록 [Block.java]

    > 블록체인을 구성하는 블록의 구조를 만들어 놓아야하므로 다음과 같은 변수를 갖는다.

    ```java
    	public String hash; // 디지털 서명을 저장.
    	public String previousHash; // 이전 해시값을 저장.
    	private String data; // 블록에 저장하는 메세지
    	private long timeStamp; // 블록이 생성될때의 시간을 기록
    	private int nonce; // proof of work를 진행할 수 있도록 하는 변수.
    ```

    

    > ![img](https://lh4.googleusercontent.com/swNGKCxbmKyTO-qhr3TtB7t8_-XMGYiPxSbVYh5B-HMYe9MRmOL7IN8g0YMniPepg03IybB8pb-BNj9NnNLJeHySl6TQRDLMh6KuP3Xd5fqBCLVwRt-O7KywtsFBq0jZ42KWHuoR)
    >
    > 블록을 생성할 때 데이터와 이전 블록의 해시값을 받아와 다음과 같이 생성한다.

    ```java
    	// 블록 생성자
    	public Block(String data, String previousHash) {
    		this.previousHash = previousHash;
    		this.data = data;
    		this.timeStamp = new Date().getTime();
    		this.hash = calculateHash();
    	}
    
    	// Hash 값을 계산하는 부분
    	public String calculateHash() {
    		String calculatedhash = StringUtil.applySha256(
    				previousHash + 
    				Long.toString(timeStamp) + 
    				Integer.toString(nonce) + 
    				data
    				);
    		return calculatedhash;
    	}	
    ```

    

  * Util [StringUtil.java]

    > 블록체인을 생성하기 위해서 해시값을 가져오는데, 그 부분을 해결할 함수를 만드는 클래스이다.
    >
    > 다음 함수에서, 하나의 input으로 String값을 가져와 SHA256으로 Hashing을 한 뒤, 한 글자씩 16진수로 변환하여 StringBuffer에 append한 후 하나의 String으로 반환한다.

    ```java
    	public static String applySha256(String input) {
    		try {
    			// 크립토그래픽 알고리즘을 SHA256으로 사용.
    			MessageDigest digest = MessageDigest.getInstance("SHA-256");
    			
    			// input을 SHA256으로 넣고 hash value.
    			byte[] hash = digest.digest(input.getBytes("UTF-8"));
    			StringBuffer hexString = new StringBuffer();
    			for(int i=0; i<hash.length; i++) {
    				String hex = Integer.toHexString(0xff & hash[i]);
    				if(hex.length() == 1) hexString.append('0');
    				hexString.append(hex);
    			}
    			
    			// 하나의 문자열로 만들어 return
    			return hexString.toString();
    		} catch (Exception e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		return null;
    	}
    ```

    

  * 블록체인 [NoobChain.java]

    > 블록을 생성하고 체인으로 엮는 클래스

    ```java
    	public static ArrayList<Block> blockchain = new ArrayList<>();
    
    	public static void main(String[] args) {
    		// ArrayList에 Block 추가.
    		blockchain.add(new Block("Hi Im the first block", "0"));
    		System.out.println("Trying to Mine block 1...");
    
    		blockchain.add(new Block(
                "Yo! Im the second block", blockchain.get(blockchain.size()-1).hash));
    		System.out.println("Trying to Mine block 2...");
    		
    		blockchain.add(new Block(
                "Yo! Im the third block", blockchain.get(blockchain.size()-1).hash));
    		System.out.println("Trying to Mine block 3...");
    		
    		System.out.println("\nBlockchain is Valid : " + isChainValid());
    		
            // 생성된 블록체인을 json타입으로 출력.
    		String blockchainJson = 
                new GsonBuilder().setPrettyPrinting().create().toJson(blockchain);
    		System.out.println("\n***** The block chain *****");
    		System.out.println(blockchainJson);
    	}
    ```

    > 위와 같이 ArrayList에 Block들을 엮으며, 이전 블록의 해시값을 생성하는 블록의 해시값에 대입한다.



#### 2.2 PoW(Proof of Work) 알고리즘 구현하기

* ##### PoW (Proof of Work) 란?

  > 블록체인 상에 존재하는 블록의 유효성을 검증하는 방식
  >
  > 이 블록체인 안에서의 유효성을 검증하기 위하여, 각 블록에 저장되어 있는 previousHash값과 실제 이전의 블록의 hash값을 비교하는 방식을 사용한다.

  ```java
  	// 블록체인의 무결성 검사
  	public static Boolean isChainValid() {
  		
  		Block currentBlock;
  		Block previousBlock;
  		
  		//블록체인 안의 해시값 검사.
  		for(int i=1; i<blockchain.size(); i++) {
  			currentBlock = blockchain.get(i);
  			previousBlock = blockchain.get(i-1);
  
  			// hash에 변화가 생기면 false를 리턴
  			if( !currentBlock.hash.equals(currentBlock.calculateHash()) ) {
  				System.out.println("Current Hashes not equal");
  				return false;
  			}
  			if( !previousBlock.hash.equals(currentBlock.previousHash) ) {
  				System.out.println("Previous Hashes not equal");
  				return false;
  			}
  		}
  
  		return true;
  	}
  ```

  >  블록체인을 생성한 뒤, 해당 블록체인의 유효성을 검사해주면 된다. 만약, 이전 블록의 해시값과 현재의 해시값이 다르다면 false를 리턴하게 되므로, 현재 생성되는 블록체인의 유효성을 검사할 수 있다.  

  

* 난이도(Difficulty) 생성하기

  > 블록을 생성할 때, 채굴자는 난이도에 설정된 만큼의 0으로 이루어진 해시값을 찾아야 하고 그만큼 돌아간 nonce(넌스)가 가장 낮은 채굴자에게 보상을 제공하게 된다.
  >
  > 먼저, 난이도를 블록체인 부분에서 생성한 뒤, 블록을 채굴하는 명령을 보낸다.

  ```java
  	public static int difficulty = 5;
  	
  	/*------------------Main 부분------------------*/
  
  	blockchain.get(0).mineBlock(difficulty);
  ```

  

  > 블록 내부에서 현재의 hash값에서 난이도만큼이 0으로 채워져 있는 지를 체크한 후,  
  > 채워져 있지 않으면 다시 hash값을 생성하는 것을 반복한다.(Brute Force) 

  ```java
  	// hash값의 일정 자리수 (difficulty) 만큼 target이 일치하는지를 검사하는 부분 
  	// -> 채굴자들이 proof-of-work를 진행하는 부분.
  	public void mineBlock(int difficulty) {
  		String target = new String(new char[difficulty]).replace('\0', '0');
  		while(!hash.substring(0, difficulty).equals(target)) {
  			nonce++;
  			hash = calculateHash();
  		}
  		System.out.println("Block Mined!!! : " + hash);
  	}
  ```



#### => 결과

> 위와 같이 블록체인을 구현하게 되면 결과는 다음과 같이 나오게 된다.

```
Trying to Mine block 1...
Block Mined!!! : 0000083ac847e645bc0ea3b6c11ea502ddebfb230f85aa967df19fd3ae21558f
Trying to Mine block 2...
Block Mined!!! : 000008bc1ea2cabe62cc0d56459798225e342e776b7cc0f9821e749a3c606acc
Trying to Mine block 3...
Block Mined!!! : 000001c0b1e87ff90c3ab2dfd994590a13d577a574419caf2a6462cf9392eeb9

Blockchain is Valid : true

***** The block chain *****
[
  {
    "hash": "0000083ac847e645bc0ea3b6c11ea502ddebfb230f85aa967df19fd3ae21558f",
    "previousHash": "0",
    "data": "Hi Im the first block",
    "timeStamp": 1559292325076,
    "nonce": 606876
  },
  {
    "hash": "000008bc1ea2cabe62cc0d56459798225e342e776b7cc0f9821e749a3c606acc",
    "previousHash": "0000083ac847e645bc0ea3b6c11ea502ddebfb230f85aa967df19fd3ae21558f",
    "data": "Yo! Im the second block",
    "timeStamp": 1559292326097,
    "nonce": 4276428
  },
  {
    "hash": "000001c0b1e87ff90c3ab2dfd994590a13d577a574419caf2a6462cf9392eeb9",
    "previousHash": "000008bc1ea2cabe62cc0d56459798225e342e776b7cc0f9821e749a3c606acc",
    "data": "Yo! Im the third block",
    "timeStamp": 1559292333258,
    "nonce": 331426
  }
]
```









