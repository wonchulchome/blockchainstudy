2.8 블록체인 구현 및 실습하기
주요 내용 요약
1. SHA-256 해시 연산을 수행해주는 기능은 유틸(Util) 클래스에 담아주기 위해 Util 클래스 만들기

       ① 클래스 생성 이후에는 바로 SHA-256 연산을 수행하는 메소드(Method)를 구현


위 소스코드를 보면 MessageDigest라는 라이브러리를 이용해서 ‘SHA-256’ 해시 알고리즘을 사용하겠다고 명시한 것을 알 수 있다. 이후에 사용자로부터 받은 입력을 SHA-256 해시를 적용하여 그 값을 바이트(Byte) 배열 형태로 반환하도록 함수가 작성되었다.

쉽게 말해 위 그림과 같이 우리가 작성한 getHash() 함수는 단순한 문자열이 들어왔을 때 그것을 SHA-256 해시를 적용한 결과 값으로 바꾸어주는 단순한 함수라고 할 수 있다. 이 때 자바에서는 메소드와 함수는 동일한 의미로 사용된다. 이제 이렇게 만들어 본 메소드를 직접 사용해보는 소스코드를 작성해보자.

       ② 블록체인 구동기(Block Chain Starter)라고 클래스 작성

해당 클래스는 실제로 소스코드가 처음 실행되는 진입점 역할을 수행하므로 메인 메소드(Main Method)를 추가해준다. 위와 같이 ‘public static void main(String[] args)’ 부분에 체크해주면 된다. 메인 메소드는 하나의 프로그램 안에 여러 개의 클래스가 공존할 때 가장 첫 번째로 실행되는 부분을 정해주기 위해 사용한다. 이후에 클래스가 생성되면 다음과 같이 코드를 작성한다

 위 소스코드는 방금 우리가 작성해준 SHA-256 해시 값을 구하는 함수 getHash()를 사용해서 결과를 확인하는 간단한 형태의 소스코드다. 구체적으로 문자열 “0”에 대한 SHA-256 해시 결과를 출력하도록 하였다. 이제 실행 버튼(F11)을 눌러 프로그램을 동작시켜보자.

프로그램 실행 결과는 위와 같다. 총 64글자의 16진수 데이터가 출력된 것을 확인할 수 있다. 그 결과는 ‘5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9’로 이해할 수 없는 무작위의 문자열이다. 이제 한 번 문자열 “0” 대신에 “1”을 넣어서 다시 실행해보자.



실행 결과로 ‘6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b’가 출력된 것을 확인할 수 있다. 이는 앞서 문자열 “0”을 넣었을 때와 비교하여 완전히 다른 결과 값이 출력되었다. 이와 같이 SHA-256 해시 알고리즘은 눈사태 효과(Avalanche Effect) 기법이 적용되어 입력 값에 따른 결과 값을 유추할 수 없고 천차만별이다. 따라서 결과 값을 보고 입력 값이 무엇이었는지 정확히 알아내기 매우 어렵다. 우연의 일치로 맞출 확률 또한 매우 희박하다.

  블록체인에서 사용되는 채굴의 원리는 이러한 눈사태 효과에서 출발한다. 간단한 작업 증명(Proof of Work) 채굴 방식을 소스코드로 구현해보자. 현재 한 글자는 16진수를 의미하므로 2^4 = 16가지 경우의 수를 표현할 수 있다. 그렇다면 작업 난이도를 2^24라고 가정해보자. 쉽게 말해 2^24번 채굴을 시도했을 때 한 번 정도 채굴이 될 수 있도록 난이도를 설정한다는 것이다.


위 소스코드는 임의의 입력 값에 대해서 SHA-256을 적용한 결과 값이 앞에서부터 6자리만큼 모두 문자 ‘0’으로 구성되어있는지 물어보고, 만약 6자리가 모두 ‘0’으로 구성되어 있다면 정답을 찾았다고 출력하는 소스코드다. 6자리가 모두 0일 확률은 2^4를 6번 곱한 수의 역수이므로 1 / 2^24다. 따라서 확률적으로 대략 천만 번 이상의 연산을 수행했을 때 한 번 채굴에 성공할 수 있는 것이다. 실제로 위 프로그램을 작동시키면 수 초 후에 다음과 같은 결과가 출력된다.

실제 대부분의 작업 증명 합의 알고리즘을 사용하는 블록체인 시스템은 위와 같이 무작위의 입력 갑을 대입하여 정답(Nonce) 과정으로 채굴(Mining)을 진행하도록 설계되어 있다. 현재 우리는 난이도를 2^24로 설정했으나 실제 블록체인 채굴 난이도는 이것보다 훨씬 어렵다는 점에서 고성능의 컴퓨터 연산이 필요한 것이다. 이번 시간에는 간단히 SHA-256 함수를 직접 구현해봄으로써 채굴이 이루어지는 과정에 대해서 이해하는 시간을 가졌다. 이와 같이 해시 값 생성 함수는 블록체인 소프트웨어에서 가장 핵심이 되면서 중요한 기능이다.

       ③ 블록(Block) 클래스를 생성

바로 이전 시간에 이어서 core 패키지 안에 새로운 클래스(Class)를 생성해준다. 클래스 이름은 Block으로 이 클래스는 하나의 블록에 대한 정보를 담고 처리하는 역할을 수행

위 소스코드에서 볼 수 있듯이 블록(Block) 클래스는 내부적으로 블록 번호(Block ID), 정답 값(Nonce), 데이터(Data)라는 세 개의 변수를 가지고 있다. 그리고 getInformation()이라는 메소드를 구현하여 현재 특정한 블록이 가지는 정보를 출력할 수 있도록 해주었다. 이제 이렇게 정의한 블록 클래스를 실제로 사용해보기 위해 BlockChainStarter 클래스의 소스코드를 수정해보자.

 위 소스코드는 블록 번호가 ‘1’이고, 정답 값이 ‘0’이며 블록이 포함하고 있는 데이터가 ‘데이터’인 하나의 블록을 생성한 뒤에 그 블록에 대한 정보를 출력한다. 작성 이후에 이클립스(Eclipse)의 실행(F11) 버튼을 눌러 프로그램을 동작시키면 다음과 같은 결과가 출력된다.

위와 같이 우리가 임의로 만들어 본 블록에 대한 정보가 성공적으로 출력되는 것을 알 수 있다. 이제 특정한 블록을 대상으로 하여 채굴(Mining)을 수행하는 메소드를 작성해보자. Block 클래스 내부에 다음과 같은 메소드를 추가해준다.

제 다음과 같이 BlockChainStarter 클래스 내용을 다음과 같이 수정하여 우리가 임의로 만든 블록이 채굴을 수행한 이후에 블록 정보를 출력하도록 해주자.


다시 프로그램을 실행해보면 위와 같이 특정한 블록에 대해 채굴이 이루어지고, 블록에 대한 정보가 출력되는 것을 알 수 있다. 또한 우리가 채굴 메소드를 구현할 때 블록 해시의 앞부분이 ‘0000’일 때 채굴에 성공하도록 설정해주었으므로 실제 출력 결과를 보았을 때 블록 해시 값의 앞부분이 ‘0000’인 것을 알 수 있다. 또한 현재 채굴의 난이도가 고정되어있도록 구현을 했으나 실제 대부분의 블록체인 시스템은 난이도가 채굴의 상황에 따라서 자동으로 변경되도록 개발된다.
  더불어 우리는 앞서 채굴 수행 메소드를 구현할 때 ‘데이터(Data)’를 해시 값 생성 함수의 입력 값으로 포함하도록 구현했다. 따라서 데이터를 조금만 변경해도 해시 값이 자동으로 변경될 것이다. 이를 확인하기 위해 다음과 같이 데이터의 내용을 ‘바뀐 데이터’로 바꾸어 실행해보자.


프로그램을 실행했을 때 위 그림과 같이 아까와는 완전히 다른 채굴 변수 값이 나오는 것을 알 수 있다. 데이터가 변경되었으므로 채굴을 성공시키는 변수 값이 아까와는 완전히 다른 정답 값(Nonce)인 것이다. 이처럼 데이터를 조금만 바꾸어도 정답 값과 해시 값이 완전히 변경된다는 점은 임의대로 해시 값을 쉽게 변경할 수 없도록 하므로 블록체인 시스템에 강력한 보안성을 제공한다.
  또한 현재는 간단히 데이터(Data)라고 표현했지만 실제 블록체인에서는 트랜잭션 정보가 이에 포함된다. 블록체인에서 특정한 블록의 내부 데이터가 변경되면 해시 값은 자동으로 변경되고, 이는 다른 블록에게도 영향을 미친다는 점에서 데이터 변조 여부를 쉽게 파악할 수 있다는 장점이 있다. 이를 직접 확인하기 위해 각 블록이 서로 연결된 형태인 블록체인(Block Chain) 구조를 만들어보자.
위와 같이 해시 값을 도출할 때 ‘이전 블록의 해시’ 값도 사용하도록 소스코드를 수정한다. 해시(Hash)는 조금만 입력이 변경되어도 출력이 완전히 뒤바뀐다는 특징이 있으므로 이전 블록의 해시 값이 변경되면 현재 블록의 해시 값도 변경된다. 다시 말해 블록체인에서 특정한 블록의 데이터를 변경하면 뒤에 이어지는 모든 블록들이 영향을 받는다는 것이다. 이는 매우 강력한 보안성을 제공한다.

위와 같이 여러 개의 블록이 연결되어 차례대로 채굴이 이루어지도록 BlockChainStarter 클래스의 소스코드를 수정한 이후에 실행해보자. 그러면 다음 그림과 같이 모든 블록들은 ‘이전 블록(Previous Block)’의 해시 값을 그대로 가지면서 현재 블록의 해시 값을 도출하게 된다.

이제 우리가 블록체인을 공격하는 악성 해커라고 가정하고, 중간에 존재하는 두 번째 블록의 데이터를 임의대로 변조해보자. 저자는 ‘변조된 데이터’라고 간단히 데이터를 수정해보았다.


두 번째 블록의 데이터를 변조하게 되면 위 그림과 같이 두 번째 블록(Block 2)를 포함해 그 뒤에 이어지는 세 번째 블록(Block 3)과 네 번째 블록(Block 4)까지 모두 영향을 받게 된다. 따라서 중간에 있는 특정한 데이터가 바뀐다면, 그 뒤에 있는 모든 블록들의 해시 값까지 다 이전과 다르게 바뀌어야만 하는 것이다. 물론 우리가 작성한 프로그램은 빠른 확인을 위해 채굴 난이도를 일부러 낮게 설정하였으므로 뒤에 있는 모든 블록 데이터까지 바꾸는 과정이 금방 이루어질 수도 있다.
  하지만 실제 블록체인은 채굴을 위해 많은 시간과 자원이 필요하다. 예를 들어 전체 블록의 개수가 N개일 때 N–101번째 블록의 데이터를 변조하고 싶다면 그 뒤로 이어지는 100개의 블록에 대해 전부 채굴(Mining)을 다시 수행해야 한다. 이는 왜 블록체인 해킹이 매우 어려운지 설명해주는 부분으로, 일반적인 해커에게는 현실적으로 불가능한 수준의 연산양이다. 실제로 현 시점에서 외계인이 지구로 와서 미래의 슈퍼컴퓨터를 주지 않는 이상 비트코인(Bit Coin)을 대상으로 하여 100개의 블록에 대한 채굴을 순식간에 수행할 정도의 컴퓨터 연산 능력을 갖추는 것은 절대 불가능하다.
   











